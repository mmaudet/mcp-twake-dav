---
phase: 02-data-transformation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/transformers/contact.ts
  - src/transformers/recurrence.ts
autonomous: true

must_haves:
  truths:
    - "vCard contact string transforms into typed ContactDTO with uid, name, emails, phones, organization"
    - "Raw vCard text preserved in _raw field on every ContactDTO"
    - "vCard version (3.0 or 4.0) auto-detected and stored in DTO"
    - "Empty or malformed vCard data returns null (not crash)"
    - "Recurring events expand into individual occurrence dates with configurable limits"
    - "Unbounded RRULE expansion capped at maxOccurrences (default 100) and maxDate (default 1 year)"
  artifacts:
    - path: "src/transformers/contact.ts"
      provides: "vCard to ContactDTO transformation"
      exports: ["transformVCard"]
      min_lines: 40
    - path: "src/transformers/recurrence.ts"
      provides: "RRULE expansion with safety limits"
      exports: ["expandRecurringEvent"]
      min_lines: 25
  key_links:
    - from: "src/transformers/contact.ts"
      to: "src/types/dtos.ts"
      via: "import ContactDTO type"
      pattern: "import.*ContactDTO.*from.*dtos"
    - from: "src/transformers/contact.ts"
      to: "ical.js"
      via: "ICAL.parse, ICAL.Component for vCard"
      pattern: "ICAL\\.parse|ICAL\\.Component"
    - from: "src/transformers/recurrence.ts"
      to: "ical.js"
      via: "ICAL.RecurExpansion"
      pattern: "ICAL\\.RecurExpansion|RecurExpansion"
---

<objective>
Implement the vCard contact transformer and recurring event expansion utility.

Purpose: Contacts from CardDAV servers must be parsed into typed ContactDTO objects preserving raw vCard text. Recurring events (RRULE) must be expandable into individual occurrence dates with safety limits to prevent runaway loops on unbounded rules.

Output: Working contact transformer and recurrence expansion utility, completing the Phase 2 data transformation layer.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-transformation/02-RESEARCH.md
@src/types/dtos.ts
@src/transformers/event.ts
@src/transformers/timezone.ts
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement vCard contact transformer</name>
  <files>src/transformers/contact.ts</files>
  <action>
Create `src/transformers/contact.ts`:

- Import ICAL from 'ical.js'
- Import ContactDTO from '../types/dtos.js'
- Import Logger type from 'pino'
- Import DAVVCard type from 'tsdav' (this is the vCard object type from tsdav)

NOTE: tsdav may not export `DAVVCard` directly. Check actual tsdav types. The vCard objects from tsdav have `{ url: string; etag?: string; data: string }` shape. If DAVVCard is not available, use `DAVObject` or define an inline type `{ url: string; etag?: string; data: string }`.

Export function `transformVCard(davVCard: { url: string; etag?: string; data: string }, logger: Logger): ContactDTO | null`

Implementation:
a. Guard: if davVCard.data is falsy, log warning and return null
b. Parse: `const jCardData = ICAL.parse(davVCard.data)`
c. Create component: `const vcard = new ICAL.Component(jCardData)`
d. Validate: if `vcard.name !== 'vcard'`, log warning and return null
e. Extract UID: `vcard.getFirstPropertyValue('uid')` -- if null/undefined, log error and return null
f. Detect version: `vcard.getFirstPropertyValue('version')` -- map to '3.0' or '4.0' (default '3.0' if missing)
g. Extract formatted name (FN): `vcard.getFirstPropertyValue('fn')`
h. Extract structured name (N): `vcard.getFirstPropertyValue('n')` -- this returns an array [family, given, middle, prefix, suffix] for vCard
i. Build name object: `{ formatted: fn || undefined, family: Array.isArray(n) ? n[0] : undefined, given: Array.isArray(n) ? n[1] : undefined }`
j. Extract emails: `vcard.getAllProperties('email').map(p => p.getFirstValue()).filter(Boolean)`
k. Extract phones: `vcard.getAllProperties('tel').map(p => p.getFirstValue()).filter(Boolean)`
l. Extract organization: `vcard.getFirstPropertyValue('org')` -- if array, take first element; if string, use directly
m. Return ContactDTO with all fields mapped, `_raw: davVCard.data`

Wrap entire body in try/catch. On error, log error with url context, return null.

CRITICAL RULES:
- Import with `.js` extensions: `from '../types/dtos.js'`
- No console.log -- use logger parameter
- Never modify UIDs from source data
- Let ical.js handle vCard 3.0 vs 4.0 detection automatically (Pitfall 5 from research)
- davVCard.data goes directly into _raw (no transformation)
- Handle edge case: some vCards have no FN property, fall back to building from N parts

NOTE on ical.js TypeScript types: Same caveat as event transformer -- may need type assertions where ical.js types are incomplete.
  </action>
  <verify>
1. `npx tsc --noEmit` compiles without errors
2. `grep "ICAL.parse" src/transformers/contact.ts` confirms ical.js parsing
3. `grep "_raw: davVCard.data" src/transformers/contact.ts` confirms raw preservation
4. `grep "version" src/transformers/contact.ts` confirms version detection
5. `grep "import.*from.*\\.js" src/transformers/contact.ts` confirms .js extensions
6. `grep -r "console.log" src/transformers/contact.ts` returns no results
  </verify>
  <done>Contact transformer function parses vCard data into typed ContactDTO. Version auto-detected (3.0/4.0). Raw vCard text preserved in _raw field. All errors handled gracefully (return null, log context). No stdout contamination.</done>
</task>

<task type="auto">
  <name>Task 2: Implement recurring event expansion with safety limits</name>
  <files>src/transformers/recurrence.ts</files>
  <action>
Create `src/transformers/recurrence.ts`:

- Import ICAL from 'ical.js'

Define and export interface `RecurrenceOptions`:
- maxOccurrences?: number (default: 100)
- maxDate?: Date (default: 1 year from now)
- startDate?: Date (optional filter: skip occurrences before this date)

Export function `expandRecurringEvent(vevent: ICAL.Component, options?: RecurrenceOptions): Date[]`

Implementation:
a. Destructure options with defaults: maxOccurrences = 100, maxDate = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), startDate = undefined
b. Get DTSTART: `vevent.getFirstPropertyValue('dtstart')` -- if null, return empty array
c. Create RecurExpansion: `new ICAL.RecurExpansion({ component: vevent, dtstart: dtstart })`
d. Loop: `while ((next = expand.next()) && count < maxOccurrences)`
   - Convert to JS Date: `next.toJSDate()`
   - If jsDate > maxDate: break (stop expanding beyond max date)
   - If startDate is set and jsDate < startDate: continue (skip but do NOT count toward maxOccurrences)
   - Push jsDate to occurrences array
   - Increment count
e. Return occurrences array

IMPORTANT NOTES:
- RecurExpansion ALWAYS starts from DTSTART (ical.js limitation, Pitfall 6 from research)
- Cannot jump to middle of sequence -- must iterate from beginning and filter
- startDate filter skips early occurrences but does NOT count them toward maxOccurrences limit
- maxOccurrences prevents runaway expansion on unbounded rules (FREQ=DAILY with no COUNT/UNTIL)
- maxDate provides additional safety net (default 1 year ahead)

CRITICAL RULES:
- No console.log
- No `.js` imports needed here (only imports from 'ical.js' package)
- Function is pure (no side effects, no logger needed)
- Handle edge case: vevent with no RRULE should still work (RecurExpansion handles DTSTART-only case)

NOTE on ical.js TypeScript types: ICAL.Component and ICAL.RecurExpansion types may need assertions. Use `as any` sparingly if the compiler rejects valid ical.js API calls.
  </action>
  <verify>
1. `npx tsc --noEmit` compiles without errors
2. `grep "RecurExpansion" src/transformers/recurrence.ts` confirms ical.js recurrence API usage
3. `grep "maxOccurrences" src/transformers/recurrence.ts` confirms safety limit
4. `grep "maxDate" src/transformers/recurrence.ts` confirms date bound
5. `grep -r "console.log" src/transformers/recurrence.ts` returns no results
  </verify>
  <done>Recurring event expansion function converts RRULE patterns into Date arrays with configurable limits. Default caps at 100 occurrences and 1 year ahead. Handles startDate filtering. No unbounded expansion possible. No stdout contamination.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no TypeScript errors across entire project
2. `grep -r "console.log\|process.stdout" src/` -- no stdout contamination
3. `grep "_raw" src/transformers/contact.ts` -- raw preservation wired
4. `grep "RecurExpansion" src/transformers/recurrence.ts` -- recurrence expansion implemented
5. All imports use `.js` extensions where needed (relative imports)
6. Full transformation layer exists: event.ts, contact.ts, timezone.ts, recurrence.ts
</verification>

<success_criteria>
- transformVCard function accepts vCard DAV object, returns ContactDTO | null
- vCard version auto-detected (3.0 or 4.0)
- Raw vCard text preserved in _raw field
- expandRecurringEvent function returns Date[] with configurable limits
- Unbounded RRULE expansion prevented (maxOccurrences=100, maxDate=1yr)
- No stdout contamination across all transformer files
- All imports use .js extensions (ESM compliance)
- Full Phase 2 transformation layer complete: DTOs + event + contact + timezone + recurrence
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-transformation/02-02-SUMMARY.md`
</output>
