---
phase: 04-calendar-query-services
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/tools/calendar/utils.ts
autonomous: true

must_haves:
  truths:
    - "chrono-node is installed and importable as ESM"
    - "Natural language date expressions ('tomorrow', 'next week', 'this Friday') parse into Date objects"
    - "Date ranges ('today', 'this week') produce TimeRange with start/end ISO strings"
    - "EventDTOs are formatted as concise human-readable text (no _raw, no etag)"
    - "Keyword and attendee search filters work case-insensitively on EventDTO arrays"
    - "Recurring events are expanded into individual occurrences within a time range"
  artifacts:
    - path: "src/tools/calendar/utils.ts"
      provides: "Date parsing, event formatting, filtering, recurrence expansion helpers"
      exports: ["parseNaturalDateRange", "getStartOfDay", "getEndOfDay", "formatEvent", "formatEventTime", "searchEventsByKeyword", "searchEventsByAttendee", "getEventsWithRecurrenceExpansion"]
    - path: "package.json"
      provides: "chrono-node dependency"
      contains: "chrono-node"
  key_links:
    - from: "src/tools/calendar/utils.ts"
      to: "src/transformers/event.ts"
      via: "import transformCalendarObject"
      pattern: "import.*transformCalendarObject.*event\\.js"
    - from: "src/tools/calendar/utils.ts"
      to: "src/transformers/recurrence.ts"
      via: "import expandRecurringEvent"
      pattern: "import.*expandRecurringEvent.*recurrence\\.js"
    - from: "src/tools/calendar/utils.ts"
      to: "src/caldav/calendar-service.ts"
      via: "import TimeRange type"
      pattern: "import.*TimeRange.*calendar-service\\.js"
---

<objective>
Install chrono-node for natural language date parsing and create the shared calendar query utilities module that all MCP tools will depend on.

Purpose: Phase 4 tools (next event, today's schedule, date range query, search) all need date parsing, event formatting, filtering, and recurrence expansion. Extracting these into a shared utils module prevents duplication and keeps individual tool files focused.

Output: `src/tools/calendar/utils.ts` with all shared helpers, chrono-node installed in package.json.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-calendar-query-services/04-RESEARCH.md

@src/caldav/calendar-service.ts
@src/transformers/event.ts
@src/transformers/recurrence.ts
@src/types/dtos.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install chrono-node dependency</name>
  <files>package.json</files>
  <action>
    Run `npm install chrono-node` in the project root to add chrono-node v2.9.0+ as a production dependency.

    chrono-node is used for natural language date parsing ("tomorrow", "next week", "this Friday", "January 15 to January 20"). It includes TypeScript definitions in v2.x.

    Verify the dependency appears in package.json under "dependencies" after installation.
  </action>
  <verify>
    Run: `cd /Users/mmaudet/work/mcp-twake && node -e "import('chrono-node').then(m => console.log('OK:', typeof m.parseDate))"`
    Expected: "OK: function"
  </verify>
  <done>chrono-node installed in package.json dependencies and importable as ESM</done>
</task>

<task type="auto">
  <name>Task 2: Create shared calendar query utilities</name>
  <files>src/tools/calendar/utils.ts</files>
  <action>
    Create `src/tools/calendar/utils.ts` with these exported functions:

    **Date helpers:**
    - `getStartOfDay(date: Date): Date` -- Sets hours to 00:00:00.000
    - `getEndOfDay(date: Date): Date` -- Sets hours to 23:59:59.999
    - `parseNaturalDateRange(expression: string): TimeRange | null` -- Uses chrono-node with `{ forwardDate: true }` and explicit `new Date()` reference date. If chrono returns a range (start+end), use both bounds. If single date, expand to full day using getStartOfDay/getEndOfDay. Return null if chrono can't parse.

    **Event formatting (concise, LLM-optimized):**
    - `formatEventTime(event: EventDTO): string` -- Format as "Mon Jan 30, 2:00 PM - 3:00 PM (Europe/Paris)". Use `toLocaleString('en-US', ...)` with weekday: 'short', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'. Include event.timezone in parentheses if present.
    - `formatEvent(event: EventDTO): string` -- Multi-line: summary on first line, time on second (indented), location on third (if present, indented with "at"), attendees on fourth (if present, indented). Example:
      ```
      Team Standup
        Mon Jan 30, 9:00 AM - 9:30 AM (Europe/Paris)
        at Conference Room A
        Attendees: Pierre Dupont, Marie Martin
      ```

    **Filtering:**
    - `searchEventsByKeyword(events: EventDTO[], keyword: string): EventDTO[]` -- Case-insensitive match on summary AND description fields.
    - `searchEventsByAttendee(events: EventDTO[], name: string): EventDTO[]` -- Case-insensitive partial match on attendee names.

    **Recurrence expansion integration:**
    - `getEventsWithRecurrenceExpansion(rawEvents: DAVCalendarObject[], timeRange: TimeRange, logger: Logger): EventDTO[]` -- Takes raw DAVCalendarObject array from CalendarService, transforms each using `transformCalendarObject()`, then for recurring events uses `expandRecurringEvent()` from Phase 2 to produce individual occurrences within the timeRange. Non-recurring events included if their startDate falls within timeRange. Returns sorted array by startDate ascending. Limits results to 50 events max (truncation protection).

    **Imports:**
    - `import * as chrono from 'chrono-node';` (default ESM import)
    - `import ICAL from 'ical.js';`
    - `import type { Logger } from 'pino';`
    - `import type { DAVCalendarObject } from 'tsdav';`
    - `import type { TimeRange } from '../../caldav/calendar-service.js';`
    - `import type { EventDTO } from '../../types/dtos.js';`
    - `import { transformCalendarObject } from '../../transformers/event.js';`
    - `import { expandRecurringEvent } from '../../transformers/recurrence.js';`

    Use ESM imports with `.js` extensions as established in the codebase.

    IMPORTANT: For `getEventsWithRecurrenceExpansion`, when expanding recurring events, parse the _raw iCalendar text to get the VEVENT component for ICAL.RecurExpansion. For each expanded occurrence, create a new EventDTO with adjusted startDate and endDate (preserving original duration). Non-recurring events are filtered by timeRange (startDate must be >= range start AND < range end).
  </action>
  <verify>
    Run: `cd /Users/mmaudet/work/mcp-twake && npx tsc --noEmit`
    Expected: No type errors. All imports resolve correctly.
  </verify>
  <done>
    - src/tools/calendar/utils.ts exists with all 8 exported functions
    - TypeScript compiles without errors
    - chrono-node imported and used for parseNaturalDateRange
    - Phase 2 transformers (event.ts, recurrence.ts) correctly referenced
    - TimeRange type from calendar-service.ts correctly imported
  </done>
</task>

</tasks>

<verification>
1. `npm ls chrono-node` shows chrono-node installed
2. `npx tsc --noEmit` succeeds with no errors
3. `src/tools/calendar/utils.ts` exports all 8 functions: parseNaturalDateRange, getStartOfDay, getEndOfDay, formatEvent, formatEventTime, searchEventsByKeyword, searchEventsByAttendee, getEventsWithRecurrenceExpansion
4. File uses ESM imports with .js extensions
5. chrono-node is called with explicit reference date and forwardDate option
</verification>

<success_criteria>
- chrono-node dependency added to package.json
- All shared utility functions exist and compile
- Utilities correctly integrate Phase 2 transformers and Phase 3 CalendarService types
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-calendar-query-services/04-01-SUMMARY.md`
</output>
