---
phase: 08-service-layer-write-methods
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/caldav/addressbook-service.ts
  - tests/unit/addressbook-service-writes.test.ts
autonomous: true

must_haves:
  truths:
    - "AddressBookService.createContact() calls tsdav createVCard with If-None-Match: * header and invalidates collection cache on success"
    - "AddressBookService.updateContact() calls tsdav updateVCard with If-Match: <etag> header and invalidates collection cache on success"
    - "AddressBookService.deleteContact() calls tsdav deleteVCard with If-Match: <etag>, fetching fresh ETag if missing, and invalidates collection cache on success"
    - "AddressBookService.findContactByUid() locates a contact across all address books and returns full data including _raw, etag, and url"
    - "412 Precondition Failed from tsdav propagated as ConflictError with actionable message"
    - "Subsequent reads after any write return fresh data (cache invalidation verified)"
  artifacts:
    - path: "src/caldav/addressbook-service.ts"
      provides: "createContact, updateContact, deleteContact, findContactByUid methods"
      contains: "createContact|updateContact|deleteContact|findContactByUid"
    - path: "tests/unit/addressbook-service-writes.test.ts"
      provides: "Unit tests for all AddressBookService write methods"
      min_lines: 100
  key_links:
    - from: "src/caldav/addressbook-service.ts"
      to: "src/errors.ts"
      via: "ConflictError import and throw on 412"
      pattern: "ConflictError"
    - from: "src/caldav/addressbook-service.ts"
      to: "src/caldav/cache.ts"
      via: "objectCache.invalidate() call after every write"
      pattern: "objectCache\\.invalidate"
    - from: "src/caldav/addressbook-service.ts"
      to: "src/transformers/contact.ts"
      via: "transformVCard for findContactByUid"
      pattern: "transformVCard"
---

<objective>
Add write methods (createContact, updateContact, deleteContact) and findContactByUid to AddressBookService with ETag-based optimistic concurrency, automatic cache invalidation, and 412 conflict detection.

Purpose: This is the contacts half of Phase 8's service layer -- downstream Phase 10 (Contact Write Tools) depends on these methods to implement create_contact, update_contact, delete_contact MCP tools.

Output: Extended AddressBookService class with 4 new methods and comprehensive unit tests with mocked tsdav client.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/caldav/addressbook-service.ts
@src/caldav/cache.ts
@src/caldav/retry.ts
@src/caldav/client.ts
@src/errors.ts
@src/types/dtos.ts
@src/transformers/contact.ts
@src/transformers/contact-builder.ts
@tests/unit/contact-builder.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for AddressBookService write methods</name>
  <files>tests/unit/addressbook-service-writes.test.ts</files>
  <action>
Create unit tests for AddressBookService write methods using mocked tsdav client. This mirrors the CalendarService test structure but for CardDAV operations.

**Test setup pattern:**
- Mock the tsdav client with vi.fn() stubs for: createVCard, updateVCard, deleteVCard, fetchVCards, fetchAddressBooks, isCollectionDirty
- Create a real CollectionCache and a Pino logger (pino({ level: 'silent' })) -- NOT mocks
- Instantiate AddressBookService with the mocked client and real logger
- Pre-seed `service['addressBooks']` with a test address book `{ url: 'https://dav.example.com/addressbooks/default/', displayName: 'Contacts', ctag: 'ctag-1' }` to skip discovery
- Pre-seed objectCache via `service['objectCache'].set(...)` when tests need cached data

**Mock tsdav Response object:**
```ts
const okResponse = { ok: true, status: 200, headers: new Headers({ etag: '"new-etag-456"' }) } as unknown as Response;
const conflictResponse = { ok: false, status: 412, headers: new Headers() } as unknown as Response;
```

**Test cases for createContact():**
1. `creates vCard with correct tsdav parameters` -- calls client.createVCard with: addressBook (matched by url), vCardString (the provided string), filename (UUID.vcf format). Verify correct arguments.
2. `invalidates collection cache after successful create` -- pre-seed cache, call createContact, verify objectCache.get(addressBookUrl) returns undefined.
3. `throws ConflictError on 412 response` -- mock createVCard to return 412 response, verify ConflictError thrown.
4. `resolves address book by name when addressBookName provided` -- pass addressBookName: 'Contacts', verify it resolves to correct URL.
5. `throws if address book not found by name` -- pass addressBookName: 'NonExistent', verify Error thrown.

**Test cases for updateContact():**
1. `updates vCard with If-Match etag` -- calls client.updateVCard with vCard: { url, data: updatedVCardString, etag }.
2. `invalidates collection cache after successful update` -- verify cache invalidated for the address book URL.
3. `throws ConflictError on 412 response` -- verify ConflictError thrown with 'contact' resource type.

**Test cases for deleteContact():**
1. `deletes vCard with If-Match etag` -- calls client.deleteVCard with vCard: { url, etag }.
2. `fetches fresh etag when etag is undefined` -- mock fetchVCards to return object with etag at that URL, verify deleteVCard called with fresh etag.
3. `invalidates collection cache after successful delete` -- verify cache invalidated.
4. `throws ConflictError on 412 response` -- verify ConflictError thrown.

**Test cases for findContactByUid():**
1. `finds contact by UID across all address books` -- mock fetchVCards to return array with one matching contact (vCard data containing target UID), verify returned object includes _raw, etag, url.
2. `returns null when UID not found` -- mock fetchVCards to return contacts without matching UID, verify null returned.
3. `searches specific address book when addressBookName provided` -- pass addressBookName, verify only that address book is searched.

**Sample vCard test data (use in findContactByUid tests):**
```
BEGIN:VCARD\r\nVERSION:3.0\r\nFN:Jean Dupont\r\nN:Dupont;Jean;;;\r\nUID:test-contact-uid-456\r\nEMAIL:jean@example.com\r\nEND:VCARD
```

**Important patterns:**
- Use same mock patterns as calendar tests for consistency
- Import ConflictError from `../../src/errors.js`
- Import transformVCard from `../../src/transformers/contact.js`
- All tests should FAIL at this point (RED phase)
  </action>
  <verify>Run `npx vitest run tests/unit/addressbook-service-writes.test.ts` -- all tests should FAIL (methods not implemented). Verify test file compiles and failures are "method not found" type, not syntax errors.</verify>
  <done>Test file exists with 13+ test cases covering createContact, updateContact, deleteContact, findContactByUid. All tests fail because methods are not yet implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Implement AddressBookService write methods (GREEN phase)</name>
  <files>src/caldav/addressbook-service.ts</files>
  <action>
Add four new methods to the AddressBookService class. Do NOT modify any existing methods.

**New imports to add at top of file:**
```ts
import { randomUUID } from 'node:crypto';
import { ConflictError } from '../errors.js';
import { transformVCard } from '../transformers/contact.js';
import type { ContactDTO } from '../types/dtos.js';
```

**Method 1: createContact(vCardString, addressBookName?)**

```ts
async createContact(vCardString: string, addressBookName?: string): Promise<{ url: string; etag: string | undefined }> {
```

Implementation:
1. Resolve target address book: if addressBookName provided, find matching from `this.addressBooks` (case-insensitive displayName match). If not found, throw Error(`Address book "${addressBookName}" not found`). If no addressBookName, use first from listAddressBooks().
2. Generate filename: `${randomUUID()}.vcf`
3. Call `this.client.createVCard({ addressBook: targetAddressBook, vCardString, filename })` wrapped in `withRetry()`.
4. Check response: if `!response.ok`, check `response.status === 412` -> throw new ConflictError('contact', 'A contact with this UID already exists. Use a different UID or update the existing contact.'). For other non-ok statuses, throw generic Error with status.
5. Extract etag from response headers: `response.headers?.get('etag') ?? undefined`
6. Invalidate cache: `this.objectCache.invalidate(targetAddressBook.url)`
7. Build result URL: `new URL(filename, targetAddressBook.url).href`
8. Log success, return `{ url: resultUrl, etag }`

**Method 2: updateContact(url, vCardString, etag)**

```ts
async updateContact(url: string, vCardString: string, etag: string): Promise<{ etag: string | undefined }> {
```

Implementation:
1. Call `this.client.updateVCard({ vCard: { url, data: vCardString, etag } })` wrapped in `withRetry()`.
2. Check response: if `!response.ok`, check status 412 -> throw ConflictError('contact'). Otherwise throw generic Error.
3. Extract new etag from response headers.
4. Invalidate cache: extract collection URL from contact URL (`url.substring(0, url.lastIndexOf('/') + 1)`), call `this.objectCache.invalidate(collectionUrl)`.
5. Log success, return `{ etag: newEtag }`

**Method 3: deleteContact(url, etag?)**

```ts
async deleteContact(url: string, etag?: string): Promise<void> {
```

Implementation:
1. If etag is undefined/missing, fetch fresh etag:
   - Extract collection URL from contact URL
   - Call `this.client.fetchVCards({ addressBook: { url: collectionUrl } as DAVAddressBook })` to fetch all vCards
   - Find the object matching the contact URL, get its etag
   - If not found or no etag, throw Error('Cannot delete: contact not found or ETag unavailable')
2. Call `this.client.deleteVCard({ vCard: { url, etag: resolvedEtag } })` wrapped in `withRetry()`.
3. Check response: if `!response.ok`, check status 412 -> throw ConflictError('contact'). Otherwise throw generic Error.
4. Invalidate cache for the collection URL.
5. Log success.

**Method 4: findContactByUid(uid, addressBookName?)**

```ts
async findContactByUid(uid: string, addressBookName?: string): Promise<ContactDTO | null> {
```

Implementation:
1. Fetch raw vCard objects: if addressBookName provided, use `fetchContactsByAddressBookName(addressBookName)`. Otherwise use `fetchAllContacts()`.
2. Iterate over DAVVCard array, call `transformVCard(obj, this.logger)` on each.
3. Find the one where `contactDTO.uid === uid`.
4. Return matching ContactDTO or null if not found.
5. Log at debug level.

**Important constraints:**
- Wrap ALL tsdav calls in `withRetry()` for network resilience
- Every successful write MUST call `this.objectCache.invalidate(collectionUrl)`
- ConflictError is ONLY thrown for HTTP 412
- Do NOT modify existing methods (listAddressBooks, fetchContacts, etc.)
- The `response` from tsdav write methods is a Fetch API Response
  </action>
  <verify>Run `npx vitest run tests/unit/addressbook-service-writes.test.ts` -- all tests should PASS. Also run `npx tsc --noEmit` to verify no type errors.</verify>
  <done>AddressBookService has createContact, updateContact, deleteContact, findContactByUid methods. All unit tests pass. No type errors. Existing methods untouched.</done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/unit/addressbook-service-writes.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- no type errors
3. `npx vitest run` -- all existing tests still pass (no regressions)
4. Verify cache invalidation: grep for `objectCache.invalidate` in addressbook-service.ts -- should appear in createContact, updateContact, deleteContact (3 occurrences)
5. Verify ConflictError: grep for `ConflictError` in addressbook-service.ts -- should appear in createContact, updateContact, deleteContact (3 occurrences)
</verification>

<success_criteria>
- AddressBookService.createContact() calls tsdav createVCard, invalidates cache, handles 412
- AddressBookService.updateContact() calls tsdav updateVCard with If-Match etag, invalidates cache, handles 412
- AddressBookService.deleteContact() calls tsdav deleteVCard with If-Match etag (fetches fresh if missing), invalidates cache, handles 412
- AddressBookService.findContactByUid() locates contact by UID across address books, returns full ContactDTO with _raw/etag/url
- All tests pass, no regressions, no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-service-layer-write-methods/08-02-SUMMARY.md`
</output>
