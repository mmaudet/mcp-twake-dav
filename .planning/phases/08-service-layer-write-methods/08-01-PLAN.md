---
phase: 08-service-layer-write-methods
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/caldav/calendar-service.ts
  - tests/unit/calendar-service-writes.test.ts
autonomous: true

must_haves:
  truths:
    - "CalendarService.createEvent() calls tsdav createCalendarObject with If-None-Match: * header and invalidates collection cache on success"
    - "CalendarService.updateEvent() calls tsdav updateCalendarObject with If-Match: <etag> header and invalidates collection cache on success"
    - "CalendarService.deleteEvent() calls tsdav deleteCalendarObject with If-Match: <etag>, fetching fresh ETag if missing, and invalidates collection cache on success"
    - "CalendarService.findEventByUid() locates an event across all calendars and returns full data including _raw, etag, and url"
    - "412 Precondition Failed from tsdav propagated as ConflictError with actionable message"
    - "Subsequent reads after any write return fresh data (cache invalidation verified)"
  artifacts:
    - path: "src/caldav/calendar-service.ts"
      provides: "createEvent, updateEvent, deleteEvent, findEventByUid methods"
      contains: "createEvent|updateEvent|deleteEvent|findEventByUid"
    - path: "tests/unit/calendar-service-writes.test.ts"
      provides: "Unit tests for all CalendarService write methods"
      min_lines: 100
  key_links:
    - from: "src/caldav/calendar-service.ts"
      to: "src/errors.ts"
      via: "ConflictError import and throw on 412"
      pattern: "ConflictError"
    - from: "src/caldav/calendar-service.ts"
      to: "src/caldav/cache.ts"
      via: "objectCache.invalidate() call after every write"
      pattern: "objectCache\\.invalidate"
    - from: "src/caldav/calendar-service.ts"
      to: "src/transformers/event.ts"
      via: "transformCalendarObject for findEventByUid"
      pattern: "transformCalendarObject"
---

<objective>
Add write methods (createEvent, updateEvent, deleteEvent) and findEventByUid to CalendarService with ETag-based optimistic concurrency, automatic cache invalidation, and 412 conflict detection.

Purpose: This is the calendar half of Phase 8's service layer -- downstream Phase 9 (Calendar Write Tools) depends on these methods to implement create_event, update_event, delete_event MCP tools.

Output: Extended CalendarService class with 4 new methods and comprehensive unit tests with mocked tsdav client.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/caldav/calendar-service.ts
@src/caldav/cache.ts
@src/caldav/retry.ts
@src/caldav/client.ts
@src/errors.ts
@src/types/dtos.ts
@src/transformers/event.ts
@src/transformers/event-builder.ts
@tests/unit/event-builder.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for CalendarService write methods</name>
  <files>tests/unit/calendar-service-writes.test.ts</files>
  <action>
Create unit tests for CalendarService write methods using mocked tsdav client. The tests verify behavior contracts without real network calls.

**Test setup pattern:**
- Mock the tsdav client with vi.fn() stubs for: createCalendarObject, updateCalendarObject, deleteCalendarObject, fetchCalendarObjects, fetchCalendars, isCollectionDirty
- Create a real CollectionCache and a Pino logger (pino({ level: 'silent' })) -- NOT mocks
- Instantiate CalendarService with the mocked client and real logger
- Pre-seed `service['calendars']` with a test calendar `{ url: 'https://dav.example.com/cal/default/', displayName: 'Default', ctag: 'ctag-1' }` to skip discovery in tests
- Pre-seed the objectCache via `service['objectCache'].set(...)` when tests need cached data

**Mock tsdav Response object:**
tsdav write methods return a raw `Response` object (Fetch API). Mock it as:
```ts
const okResponse = { ok: true, status: 200, headers: new Headers({ etag: '"new-etag-123"' }) } as unknown as Response;
const conflictResponse = { ok: false, status: 412, headers: new Headers() } as unknown as Response;
```

**Test cases for createEvent():**
1. `creates calendar object with correct tsdav parameters` -- calls client.createCalendarObject with: calendar (matched by url), iCalString (the provided string), filename (UUID.ics format). Verify the method was called with the right arguments.
2. `invalidates collection cache after successful create` -- pre-seed cache with entries for the calendar URL, call createEvent, verify objectCache.get(calendarUrl) returns undefined.
3. `throws ConflictError on 412 response` -- mock createCalendarObject to return { ok: false, status: 412 }, verify ConflictError is thrown.
4. `resolves calendar by name when calendarName provided` -- pass calendarName: 'Default', verify it resolves to the correct calendar URL.
5. `throws if calendar not found by name` -- pass calendarName: 'NonExistent', verify Error thrown with message about calendar not found.

**Test cases for updateEvent():**
1. `updates calendar object with If-Match etag` -- calls client.updateCalendarObject with calendarObject: { url, data: updatedICalString, etag }, verify etag passed correctly.
2. `invalidates collection cache after successful update` -- pre-seed cache, call updateEvent, verify cache invalidated for the calendar URL. Extract calendar URL from event URL by removing filename (everything after last `/`).
3. `throws ConflictError on 412 response` -- verify ConflictError thrown with 'event' resource type.

**Test cases for deleteEvent():**
1. `deletes calendar object with If-Match etag` -- calls client.deleteCalendarObject with calendarObject: { url, etag }.
2. `fetches fresh etag when etag is undefined` -- mock fetchCalendarObjects to return object with etag at that URL, then verify deleteCalendarObject called with fresh etag.
3. `invalidates collection cache after successful delete` -- verify cache invalidated.
4. `throws ConflictError on 412 response` -- verify ConflictError thrown.

**Test cases for findEventByUid():**
1. `finds event by UID across all calendars` -- mock fetchCalendarObjects to return array with one matching event (iCalendar data containing the target UID), verify returned object includes _raw, etag, url.
2. `returns null when UID not found` -- mock fetchCalendarObjects to return events without matching UID, verify null returned.
3. `searches specific calendar when calendarName provided` -- pass calendarName, verify only that calendar is searched (not all).

**Important patterns:**
- Use `vi.fn()` for client method mocks, NOT manual stubs
- Use `describe` blocks to group by method name
- Use `beforeEach` to reset mocks and create fresh service instances
- Import ConflictError from `../../src/errors.js` to verify instanceof checks
- Import transformCalendarObject from `../../src/transformers/event.js` -- the test needs REAL iCalendar data strings that transformCalendarObject can parse to extract UID

**Sample iCalendar test data (use in findEventByUid tests):**
```
BEGIN:VCALENDAR\r\nVERSION:2.0\r\nBEGIN:VEVENT\r\nUID:test-uid-123\r\nSUMMARY:Test Event\r\nDTSTART:20250315T140000Z\r\nDTEND:20250315T150000Z\r\nEND:VEVENT\r\nEND:VCALENDAR
```

All tests should FAIL at this point (RED phase) because the methods don't exist yet.
  </action>
  <verify>Run `npx vitest run tests/unit/calendar-service-writes.test.ts` -- all tests should FAIL (methods not implemented). Verify the test file compiles and the failures are "method not found" or "is not a function" type errors, not syntax errors.</verify>
  <done>Test file exists with 13+ test cases covering createEvent, updateEvent, deleteEvent, findEventByUid. All tests fail because methods are not yet implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Implement CalendarService write methods (GREEN phase)</name>
  <files>src/caldav/calendar-service.ts</files>
  <action>
Add four new methods to the CalendarService class. Do NOT modify any existing methods.

**New imports to add at top of file:**
```ts
import { randomUUID } from 'node:crypto';
import { ConflictError } from '../errors.js';
import { transformCalendarObject } from '../transformers/event.js';
import type { EventDTO } from '../types/dtos.js';
```

**Method 1: createEvent(iCalString, calendarName?)**

```ts
async createEvent(iCalString: string, calendarName?: string): Promise<{ url: string; etag: string | undefined }> {
```

Implementation:
1. Resolve target calendar: if calendarName provided, find matching calendar from `this.calendars` (case-insensitive displayName match). If not found, throw Error(`Calendar "${calendarName}" not found`). If no calendarName, use first calendar from listCalendars().
2. Generate filename: `${randomUUID()}.ics`
3. Call `this.client.createCalendarObject({ calendar: targetCalendar, iCalString, filename })` wrapped in `withRetry()`.
4. Check response: if `!response.ok`, check `response.status === 412` -> throw new ConflictError('event', 'An event with this UID already exists. Use a different UID or update the existing event.'). For other non-ok statuses, throw generic Error with status.
5. Extract etag from response headers: `response.headers?.get('etag') ?? undefined`
6. Invalidate cache: `this.objectCache.invalidate(targetCalendar.url)`
7. Build result URL: `new URL(filename, targetCalendar.url).href`
8. Log success, return `{ url: resultUrl, etag }`

**Method 2: updateEvent(url, iCalString, etag)**

```ts
async updateEvent(url: string, iCalString: string, etag: string): Promise<{ etag: string | undefined }> {
```

Implementation:
1. Call `this.client.updateCalendarObject({ calendarObject: { url, data: iCalString, etag } })` wrapped in `withRetry()`.
2. Check response: if `!response.ok`, check status 412 -> throw ConflictError('event'). Otherwise throw generic Error.
3. Extract new etag from response headers.
4. Invalidate cache: extract collection URL from event URL (everything up to and including last `/`), call `this.objectCache.invalidate(collectionUrl)`.
5. Log success, return `{ etag: newEtag }`

**Method 3: deleteEvent(url, etag?)**

```ts
async deleteEvent(url: string, etag?: string): Promise<void> {
```

Implementation:
1. If etag is undefined/missing, fetch fresh etag:
   - Extract collection URL from event URL (up to and including last `/`)
   - Call `this.client.fetchCalendarObjects({ calendar: { url: collectionUrl } as DAVCalendar })` to fetch all objects in that collection
   - Find the object matching the event URL, get its etag
   - If not found or no etag, throw Error('Cannot delete: event not found or ETag unavailable')
2. Call `this.client.deleteCalendarObject({ calendarObject: { url, etag: resolvedEtag } })` wrapped in `withRetry()`.
3. Check response: if `!response.ok`, check status 412 -> throw ConflictError('event'). Otherwise throw generic Error.
4. Invalidate cache for the collection URL.
5. Log success.

**Method 4: findEventByUid(uid, calendarName?)**

```ts
async findEventByUid(uid: string, calendarName?: string): Promise<EventDTO | null> {
```

Implementation:
1. Fetch raw calendar objects: if calendarName provided, use `fetchEventsByCalendarName(calendarName)`. Otherwise use `fetchAllEvents()` (no timeRange to get all events).
2. Iterate over DAVCalendarObject array, call `transformCalendarObject(obj, this.logger)` on each.
3. Find the one where `eventDTO.uid === uid`.
4. Return matching EventDTO or null if not found.
5. Log at debug level whether found or not.

**Helper for extracting collection URL:**
Create a private method or inline: `const collectionUrl = url.substring(0, url.lastIndexOf('/') + 1);`

**Important constraints:**
- Wrap ALL tsdav calls in `withRetry()` for network resilience
- Every successful write MUST call `this.objectCache.invalidate(collectionUrl)`
- ConflictError is ONLY thrown for HTTP 412 -- other errors use generic Error
- Do NOT modify existing methods (listCalendars, fetchEvents, etc.)
- The `response` from tsdav write methods is a Fetch API Response -- use `.ok`, `.status`, `.headers.get()`
  </action>
  <verify>Run `npx vitest run tests/unit/calendar-service-writes.test.ts` -- all tests should PASS. Also run `npx tsc --noEmit` to verify no type errors.</verify>
  <done>CalendarService has createEvent, updateEvent, deleteEvent, findEventByUid methods. All unit tests pass. No type errors. Existing methods untouched.</done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/unit/calendar-service-writes.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- no type errors
3. `npx vitest run` -- all existing tests still pass (no regressions)
4. Verify cache invalidation: grep for `objectCache.invalidate` in calendar-service.ts -- should appear in createEvent, updateEvent, deleteEvent (3 occurrences)
5. Verify ConflictError: grep for `ConflictError` in calendar-service.ts -- should appear in createEvent, updateEvent, deleteEvent (3 occurrences)
</verification>

<success_criteria>
- CalendarService.createEvent() calls tsdav createCalendarObject, invalidates cache, handles 412
- CalendarService.updateEvent() calls tsdav updateCalendarObject with If-Match etag, invalidates cache, handles 412
- CalendarService.deleteEvent() calls tsdav deleteCalendarObject with If-Match etag (fetches fresh if missing), invalidates cache, handles 412
- CalendarService.findEventByUid() locates event by UID across calendars, returns full EventDTO with _raw/etag/url
- All tests pass, no regressions, no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-service-layer-write-methods/08-01-SUMMARY.md`
</output>
