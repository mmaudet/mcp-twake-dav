---
phase: 11-freebusy-and-annotations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/caldav/calendar-service.ts
  - src/tools/calendar/utils.ts
  - src/tools/calendar/check-availability.ts
autonomous: true

must_haves:
  truths:
    - "check_availability tool returns busy periods for a given time range"
    - "Free/busy falls back to client-side computation when server-side fails"
    - "TRANSPARENT events are excluded from busy period computation"
    - "Overlapping busy periods are merged into single intervals"
  artifacts:
    - path: "src/tools/calendar/check-availability.ts"
      provides: "check_availability MCP tool with dual-path free/busy"
      min_lines: 80
    - path: "src/tools/calendar/utils.ts"
      provides: "computeBusyPeriods() and mergeBusyPeriods() utilities"
      contains: "computeBusyPeriods"
    - path: "src/caldav/calendar-service.ts"
      provides: "getAuthHeaders() method for freeBusyQuery auth injection"
      contains: "getAuthHeaders"
  key_links:
    - from: "src/tools/calendar/check-availability.ts"
      to: "src/tools/calendar/utils.ts"
      via: "computeBusyPeriods import"
      pattern: "import.*computeBusyPeriods.*utils"
    - from: "src/tools/calendar/check-availability.ts"
      to: "src/caldav/calendar-service.ts"
      via: "calendarService.getAuthHeaders() for freeBusyQuery"
      pattern: "getAuthHeaders"
    - from: "src/tools/calendar/check-availability.ts"
      to: "tsdav"
      via: "freeBusyQuery standalone function import"
      pattern: "import.*freeBusyQuery.*tsdav"
---

<objective>
Create the check_availability tool with dual-path free/busy query (server-side REPORT with client-side fallback) and supporting utilities.

Purpose: Enables users to check calendar availability for a time range ("Am I free Thursday afternoon?"), completing ADV-01 requirement. This is the last new tool in v2.
Output: New check-availability.ts tool module, busy period computation utilities in utils.ts, auth header method in CalendarService.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-freebusy-and-annotations/11-RESEARCH.md

@src/tools/calendar/utils.ts
@src/tools/calendar/next-event.ts
@src/tools/calendar/create-event.ts
@src/caldav/calendar-service.ts
@src/caldav/client.ts
@src/types/dtos.ts
@src/tools/index.ts
@src/index.ts
@src/config/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth header access + busy period utilities</name>
  <files>
    src/caldav/calendar-service.ts
    src/tools/calendar/utils.ts
  </files>
  <action>
**Part A: CalendarService auth header access (calendar-service.ts)**

The CalendarService needs to provide auth headers for the standalone tsdav `freeBusyQuery` function. The problem: CalendarService only receives a `DAVClientType` (tsdav client), but the client does not expose auth headers publicly.

Solution: Accept a `Config` parameter in CalendarService constructor and add a `getAuthHeaders()` method that reconstructs headers from config (same logic as `getAuthConfig()` in client.ts).

1. Add `import type { Config } from '../config/schema.js';` to imports
2. Add private `config: Config` field to CalendarService class
3. Update constructor signature to `constructor(client: DAVClientType, logger: Logger, config: Config)` -- add config as third parameter
4. Store `this.config = config;`
5. Add public method:
```typescript
getAuthHeaders(): Record<string, string> {
  if (this.config.DAV_AUTH_METHOD === 'bearer') {
    return { authorization: `Bearer ${this.config.DAV_TOKEN}` };
  }
  if (this.config.DAV_AUTH_METHOD === 'esntoken') {
    return { ESNToken: this.config.DAV_TOKEN! };
  }
  const basicToken = Buffer.from(`${this.config.DAV_USERNAME}:${this.config.DAV_PASSWORD}`).toString('base64');
  return { authorization: `Basic ${basicToken}` };
}
```

6. Update `src/index.ts` to pass config to CalendarService constructor:
   Change `new CalendarService(clients.caldav, logger)` to `new CalendarService(clients.caldav, logger, config)`

7. Update `src/server.ts` to accept and forward config:
   - Add `config?: Config` parameter to `createServer()`
   - Pass it through to `registerAllTools()`
   - Actually, WAIT -- the config is only needed by CalendarService, which is already constructed by the time createServer is called. The CalendarService instance already has getAuthHeaders(). No server.ts change needed.

8. Update `tests/integration/tools.test.ts` mock: The test uses `createServer(calendarService, addressBookService, logger)` with a mock CalendarService. Since CalendarService is cast with `as unknown as CalendarService`, the mock doesn't need the config parameter. No test change needed here.

**Part B: Busy period computation utilities (utils.ts)**

Add two new exported functions to the END of `src/tools/calendar/utils.ts`:

1. `mergeBusyPeriods(periods: FreeBusyPeriod[]): FreeBusyPeriod[]`
   - Import `FreeBusyPeriod` from `../../types/dtos.js`
   - If empty array, return empty
   - Sort by start time ascending
   - Merge overlapping intervals: if `lastMerged.end >= current.start`, extend `lastMerged.end` to `max(lastMerged.end, current.end)`
   - Otherwise push as new period
   - All merged periods get type `'BUSY'`
   - Return merged array

2. `computeBusyPeriods(events: EventDTO[], logger: Logger): FreeBusyPeriod[]`
   - Import `ICAL` (already imported in utils.ts)
   - For each event:
     a. Parse `event._raw` with `ICAL.parse()` to get jcal data
     b. Create component, get first 'vevent' subcomponent
     c. Check `vevent.getFirstPropertyValue('transp')` -- if `'TRANSPARENT'`, skip this event
     d. Otherwise, create `FreeBusyPeriod` with `start: event.startDate, end: event.endDate, type: 'BUSY'`
   - Call `mergeBusyPeriods()` on the resulting periods
   - Return merged periods

IMPORTANT: The `ICAL` import already exists at the top of utils.ts. Add `FreeBusyPeriod` to the existing dtos import line.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Verify that `src/caldav/calendar-service.ts` exports `getAuthHeaders()` method and `src/tools/calendar/utils.ts` exports `computeBusyPeriods` and `mergeBusyPeriods`.
  </verify>
  <done>
CalendarService has `getAuthHeaders()` method returning proper auth headers based on config. utils.ts exports `computeBusyPeriods()` that filters TRANSPARENT events and merges overlapping busy periods. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create check_availability tool module</name>
  <files>
    src/tools/calendar/check-availability.ts
    src/index.ts
  </files>
  <action>
Create `src/tools/calendar/check-availability.ts` following the pattern from `next-event.ts` and `create-event.ts`.

**File structure:**

```typescript
/**
 * MCP tool: check_availability (ADV-01)
 *
 * Checks calendar availability for a time range using dual-path approach:
 * 1. Server-side free-busy-query REPORT (RFC 4791 s7.10)
 * 2. Client-side fallback: fetch events, filter TRANSPARENT, merge busy periods
 */
```

**Imports:**
- `z` from 'zod'
- `McpServer` type from MCP SDK
- `Logger` type from 'pino'
- `CalendarService` type from `../../caldav/calendar-service.js`
- `freeBusyQuery` from 'tsdav' (standalone function, NOT client method)
- `* as chrono` from 'chrono-node'
- `ICAL` from 'ical.js'
- `resolveCalendarEvents, getEventsWithRecurrenceExpansion, computeBusyPeriods` from './utils.js'
- `FreeBusyPeriod, FreeBusyResult` from `../../types/dtos.js`

**Export function:** `registerCheckAvailabilityTool(server, calendarService, logger, defaultCalendar?)`

**Tool registration:** `server.tool(name, description, schema, handler)` -- 4 parameters only (annotations added in Plan 02)

**Tool name:** `'check_availability'`

**Description:** `'Check calendar availability for a time range. Returns busy periods or confirms availability. Supports natural language dates (e.g., "Thursday afternoon", "next week Monday to Friday").'`

**Schema (Zod):**
- `start`: `z.string().describe('Start of time range. Supports natural language (e.g., "Thursday afternoon", "tomorrow at 9am") or ISO 8601.')`
- `end`: `z.string().describe('End of time range. Supports natural language or ISO 8601.')`
- `calendar`: `z.string().optional().describe('Calendar name to check. Use "all" to check all calendars. ' + defaultCalendar text)`

**Handler logic:**

1. Parse start/end dates using chrono-node (same pattern as create-event.ts):
   ```
   let startDate = chrono.parseDate(params.start);
   if (!startDate) { startDate = new Date(params.start); }
   if (isNaN(startDate.getTime())) { return error "Could not parse start date" }
   ```
   Same for endDate.

2. Validate: end must be after start (same pattern as create-event.ts)

3. Create timeRange: `{ start: startDate.toISOString(), end: endDate.toISOString() }`

4. **Try server-side free-busy-query first:**
   ```typescript
   try {
     // Get auth headers from CalendarService
     const authHeaders = calendarService.getAuthHeaders();

     // Resolve calendar URL for freeBusyQuery
     const calendars = await calendarService.listCalendars();
     const resolvedCalendar = params.calendar === 'all' ? undefined : (params.calendar || defaultCalendar);

     let targetUrl: string;
     if (resolvedCalendar) {
       const match = calendars.find(c =>
         String(c.displayName || '').toLowerCase() === resolvedCalendar.toLowerCase()
       );
       if (match) {
         targetUrl = match.url;
       } else {
         throw new Error('Calendar not found, use fallback');
       }
     } else {
       // Use first calendar URL for server-side query
       targetUrl = calendars[0]?.url;
       if (!targetUrl) throw new Error('No calendars available');
     }

     const response = await freeBusyQuery({
       url: targetUrl,
       timeRange: {
         start: startDate.toISOString(),
         end: endDate.toISOString(),
       },
       headers: authHeaders,
     });

     // Parse VFREEBUSY response with ical.js
     // response is DAVResponse[] or single response -- check tsdav types
     // The response body contains iCalendar VFREEBUSY data
     const responseData = Array.isArray(response) ? response : [response];
     const busyPeriods: FreeBusyPeriod[] = [];

     for (const resp of responseData) {
       if (resp.props?.calendarData?.._value || resp.raw) {
         const icalData = resp.props?.calendarData?._value || resp.raw || '';
         if (icalData && typeof icalData === 'string') {
           try {
             const jcalData = ICAL.parse(icalData);
             const comp = new ICAL.Component(jcalData);
             const vfreebusy = comp.getFirstSubcomponent('vfreebusy');
             if (vfreebusy) {
               const fbProps = vfreebusy.getAllProperties('freebusy');
               for (const prop of fbProps) {
                 const period = prop.getFirstValue();
                 if (period) {
                   busyPeriods.push({
                     start: period.start.toJSDate(),
                     end: period.end.toJSDate(),
                     type: prop.getParameter('fbtype') || 'BUSY',
                   });
                 }
               }
             }
           } catch (parseErr) {
             logger.debug({ parseErr }, 'Failed to parse VFREEBUSY response, will use fallback');
             throw parseErr; // trigger fallback
           }
         }
       }
     }

     if (busyPeriods.length > 0 || responseData.some(r => r.ok !== false)) {
       // Server-side query succeeded
       logger.info({ periods: busyPeriods.length }, 'Server-side free-busy-query succeeded');
       return formatFreeBusyResponse(busyPeriods, startDate, endDate);
     }

     // If no useful data, fall through to fallback
     throw new Error('No VFREEBUSY data in server response');
   } catch (serverErr) {
     logger.info({ err: serverErr }, 'Server-side free-busy-query failed, using client-side fallback');
   }
   ```

5. **Client-side fallback (ALWAYS reached if server-side fails):**
   ```typescript
   // Fetch events using existing resolveCalendarEvents utility
   const rawEvents = await resolveCalendarEvents(
     calendarService, params.calendar, defaultCalendar, timeRange
   );

   // Transform with recurrence expansion
   const events = getEventsWithRecurrenceExpansion(rawEvents, timeRange, logger);

   // Compute busy periods (filters TRANSPARENT, merges overlaps)
   const busyPeriods = computeBusyPeriods(events, logger);

   return formatFreeBusyResponse(busyPeriods, startDate, endDate);
   ```

6. **Add helper function `formatFreeBusyResponse`** (inside the module, not exported):
   ```typescript
   function formatFreeBusyResponse(
     periods: FreeBusyPeriod[],
     queryStart: Date,
     queryEnd: Date
   ) {
     if (periods.length === 0) {
       return {
         content: [{
           type: 'text' as const,
           text: `You are free from ${queryStart.toLocaleString()} to ${queryEnd.toLocaleString()}. No busy periods found.`,
         }],
       };
     }

     const periodLines = periods.map((p, i) => {
       const startStr = p.start.toLocaleString('en-US', {
         weekday: 'short', month: 'short', day: 'numeric',
         hour: 'numeric', minute: '2-digit',
       });
       const endStr = p.end.toLocaleString('en-US', {
         hour: 'numeric', minute: '2-digit',
       });
       return `${i + 1}. ${startStr} - ${endStr}`;
     });

     const text = [
       `Busy periods from ${queryStart.toLocaleString()} to ${queryEnd.toLocaleString()}:`,
       '',
       ...periodLines,
       '',
       `${periods.length} busy period(s) found.`,
     ].join('\n');

     return {
       content: [{
         type: 'text' as const,
         text,
       }],
     };
   }
   ```

7. **Error handling:** Wrap entire handler in try/catch, same pattern as other tools:
   ```typescript
   catch (err) {
     logger.error({ err }, 'Error in check_availability');
     return {
       content: [{
         type: 'text' as const,
         text: `Error: ${err instanceof Error ? err.message : String(err)}`,
       }],
       isError: true,
     };
   }
   ```

**CRITICAL NOTES:**
- `freeBusyQuery` is imported from 'tsdav' as a STANDALONE function, NOT `client.freeBusyQuery()`
- The server-side path may fail on many servers -- the fallback MUST work independently
- The try/catch around server-side ensures ANY error (401, 404, 501, parse failure) triggers fallback
- The fallback uses existing `resolveCalendarEvents` + `getEventsWithRecurrenceExpansion` + `computeBusyPeriods`
- Do NOT register this tool in index.ts yet -- Plan 02 will handle registration alongside annotations

**Update src/index.ts:**
- Actually, since Plan 02 depends on this file existing, we SHOULD leave index.ts registration to Plan 02 to avoid file ownership conflict.

**However**, we DO need to update `src/index.ts` to pass `config` through to `registerAllTools` IF the CalendarService constructor change requires it. But since CalendarService is already constructed in `src/index.ts` before `createServer` is called, and the tool gets `calendarService` as a parameter, the tool can call `calendarService.getAuthHeaders()` directly. No changes to index.ts or server.ts signatures needed for auth headers.

**Update src/index.ts ONLY to pass config to CalendarService:**
In `src/index.ts`, change line:
```
const calendarService = new CalendarService(clients.caldav, logger);
```
to:
```
const calendarService = new CalendarService(clients.caldav, logger, config);
```

This is the ONLY change needed in index.ts for this task. The tool registration happens in Plan 02.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Verify that `src/tools/calendar/check-availability.ts` exports `registerCheckAvailabilityTool`. Run `npm test` to verify existing tests still pass (no regressions from CalendarService constructor change -- the test mocks CalendarService with `as unknown`, so adding a parameter doesn't break it).
  </verify>
  <done>
`check-availability.ts` exists with dual-path free/busy logic (server-side freeBusyQuery with client-side fallback). CalendarService constructor accepts config for auth header generation. `src/index.ts` passes config to CalendarService. TypeScript compiles. Existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm test` passes (existing integration tests not broken)
3. `src/tools/calendar/check-availability.ts` exists and exports `registerCheckAvailabilityTool`
4. `src/tools/calendar/utils.ts` exports `computeBusyPeriods` and `mergeBusyPeriods`
5. `src/caldav/calendar-service.ts` has `getAuthHeaders()` method
6. `src/index.ts` passes `config` to CalendarService constructor
</verification>

<success_criteria>
- check_availability tool module is complete with dual-path free/busy logic
- Server-side freeBusyQuery path uses standalone tsdav function with manual auth headers
- Client-side fallback fetches events, filters TRANSPARENT, merges overlapping busy periods
- Natural language date parsing supported via chrono-node
- All existing tests pass without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/11-freebusy-and-annotations/11-01-SUMMARY.md`
</output>
