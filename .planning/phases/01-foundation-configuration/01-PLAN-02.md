---
phase: 01-foundation-configuration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/errors.ts
  - src/caldav/client.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Server starts without errors when valid environment variables provided"
    - "Connection to CalDAV/CardDAV server succeeds with Basic Auth credentials"
    - "Invalid credentials produce AI-friendly error message suggesting credential check"
    - "Unreachable server produces AI-friendly error with common fix suggestions"
    - "Server exits with clear error when configuration is invalid"
    - "MCP server connects via stdio transport after successful validation"
  artifacts:
    - path: "src/errors.ts"
      provides: "AI-friendly error message formatting"
      exports: ["formatStartupError"]
    - path: "src/caldav/client.ts"
      provides: "tsdav CalDAV/CardDAV client wrapper with connection validation"
      exports: ["createCalDAVClient", "validateConnection"]
    - path: "src/index.ts"
      provides: "Entry point: config validation -> logger init -> connection test -> MCP server start"
      contains: "main()"
  key_links:
    - from: "src/index.ts"
      to: "src/config/schema.ts"
      via: "loadConfig() call in main()"
      pattern: "loadConfig\\(\\)"
    - from: "src/index.ts"
      to: "src/config/logger.ts"
      via: "createLogger() call in main()"
      pattern: "createLogger\\("
    - from: "src/index.ts"
      to: "src/caldav/client.ts"
      via: "validateConnection() call in main()"
      pattern: "validateConnection\\("
    - from: "src/index.ts"
      to: "src/errors.ts"
      via: "formatStartupError() in catch block"
      pattern: "formatStartupError\\("
    - from: "src/index.ts"
      to: "@modelcontextprotocol/sdk"
      via: "McpServer + StdioServerTransport"
      pattern: "server\\.connect\\(transport\\)"
    - from: "src/caldav/client.ts"
      to: "tsdav"
      via: "createDAVClient() for Basic Auth connection"
      pattern: "createDAVClient\\("
---

<objective>
Wire the CalDAV client, AI-friendly error handling, and MCP stdio server entry point.

Purpose: Complete the startup flow (validate config -> init logger -> test CalDAV connection -> start MCP server) with actionable error messages that help Claude diagnose configuration issues for users.

Output: A working MCP server that validates CalDAV/CardDAV connectivity at startup and runs on stdio transport. Errors are formatted for AI consumption with "what went wrong" + "how to fix it" pattern.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-configuration/01-RESEARCH.md
@.planning/phases/01-foundation-configuration/01-CONTEXT.md
@.planning/phases/01-foundation-configuration/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AI-friendly error formatting and CalDAV client wrapper</name>
  <files>
    src/errors.ts
    src/caldav/client.ts
  </files>
  <action>
    1. Create `src/errors.ts`:
       - Export a `formatStartupError` function that takes an `Error` and optional config context, returns a user-actionable string.
       - Pattern: "What went wrong" + "How to fix it"
       - Handle these error categories:
         - **ZodError** (from zod): Format each issue as "FIELD: message". Append: "Check your environment variables (DAV_URL, DAV_USERNAME, DAV_PASSWORD)."
         - **Authentication failure** (401, 'auth', 'unauthorized'): "Authentication failed for the configured CalDAV server. Verify DAV_USERNAME and DAV_PASSWORD are correct."
         - **DNS/unreachable** (ENOTFOUND): "Cannot find server at [URL]. Check the DAV_URL is spelled correctly and the server exists."
         - **Timeout** (ETIMEDOUT, timeout): "Connection to [URL] timed out. Check the server is running and accessible from your network."
         - **Connection refused** (ECONNREFUSED): "Connection refused by [URL]. Check the server is running and the port is correct."
         - **SSL/TLS** (certificate, CERT, SSL): "SSL certificate error for [URL]. The server may have an invalid or self-signed certificate."
         - **Fallback**: "Unexpected error: [message]. Check your configuration and try again."
       - Import `ZodError` from 'zod' for instanceof check.

    2. Create `src/caldav/client.ts`:
       - Import `createDAVClient` from 'tsdav'
       - Import `Config` type from config/schema
       - Import logger type from config/logger

       - Export `createCalDAVClient(config: Config)` function:
         ```typescript
         export async function createCalDAVClient(config: Config) {
           return createDAVClient({
             serverUrl: config.DAV_URL,
             credentials: {
               username: config.DAV_USERNAME,
               password: config.DAV_PASSWORD,
             },
             authMethod: 'Basic',
             defaultAccountType: 'caldav',
           });
         }
         ```

       - Export `validateConnection(config: Config, logger: Logger)` function:
         - Creates the DAV client via `createCalDAVClient(config)`
         - Attempts `client.fetchCalendars()` with a 10-second timeout using `Promise.race`:
           ```typescript
           await Promise.race([
             client.fetchCalendars(),
             new Promise((_, reject) =>
               setTimeout(() => reject(new Error('Connection timeout: server did not respond within 10 seconds')), 10000)
             )
           ]);
           ```
         - On success: logger.info with calendar count, return the client
         - On failure: throw the error (let caller handle with formatStartupError)
         - Log connection attempt: `logger.info({ url: config.DAV_URL }, 'Testing CalDAV connection...')`
         - Log success: `logger.info({ calendars: result.length }, 'CalDAV connection validated')`

       IMPORTANT:
       - Use `.js` extensions in all relative imports (ESM)
       - The DAVClient type from tsdav is the return type of createDAVClient -- use `Awaited<ReturnType<typeof createDAVClient>>` or import `DAVClient` if available
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `src/errors.ts` handles ZodError, auth, DNS, timeout, connection refused, SSL, and fallback cases
    - `src/caldav/client.ts` exports createCalDAVClient and validateConnection
    - validateConnection uses 10-second timeout via Promise.race
    - No console.log or process.stdout in either file
  </verify>
  <done>
    AI-friendly error formatter covers all common startup failure scenarios. CalDAV client wrapper abstracts tsdav initialization and connection validation with timeout protection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MCP server entry point with full startup validation</name>
  <files>
    src/index.ts
  </files>
  <action>
    Create `src/index.ts` as the entry point implementing the full startup sequence:

    1. Add shebang line: `#!/usr/bin/env node`

    2. Import all modules:
       - `McpServer` from `@modelcontextprotocol/sdk/server/mcp.js`
       - `StdioServerTransport` from `@modelcontextprotocol/sdk/server/stdio.js`
       - `loadConfig` from `./config/schema.js`
       - `createLogger` from `./config/logger.js`
       - `validateConnection` from `./caldav/client.js`
       - `formatStartupError` from `./errors.js`
       - `ZodError` from `zod`

    3. Implement `async function main()`:
       ```
       Step 1: Load and validate configuration
         const config = loadConfig();

       Step 2: Initialize logger (uses config.LOG_LEVEL)
         const logger = createLogger(config.LOG_LEVEL);
         logger.info('Configuration validated successfully');

       Step 3: Test CalDAV/CardDAV connection
         const client = await validateConnection(config, logger);

       Step 4: Initialize MCP server
         const server = new McpServer({
           name: "mcp-twake",
           version: "0.1.0",
           description: "CalDAV/CardDAV MCP server for calendar and contact queries",
         });

       Step 5: Connect stdio transport
         const transport = new StdioServerTransport();
         await server.connect(transport);
         logger.info('MCP server running on stdio transport');
       ```

    4. Error handling in main():
       - Wrap entire main() body in try/catch
       - In catch block:
         - Call `formatStartupError(error)` to get user-friendly message
         - Log with `console.error()` (stderr) for immediate visibility even if logger not yet initialized
         - Also log with logger if it exists
         - Call `process.exit(1)` to fail fast

    5. Call `main()` at module level:
       ```typescript
       main().catch((error) => {
         console.error('Fatal startup error:', error);
         process.exit(1);
       });
       ```

    6. After writing, verify the full build:
       - Run `npx tsc` to compile to `build/`
       - Verify `build/index.js` exists
       - Verify shebang line is present in build output

    CRITICAL RULES:
    - NEVER use console.log() -- only console.error() for pre-logger errors
    - NEVER write to process.stdout -- reserved for MCP JSON-RPC protocol
    - ALL logging goes through Pino (stderr) or console.error (stderr)
    - Use `.js` extensions in all relative imports
    - The startup sequence MUST be: config -> logger -> connection test -> MCP server
    - If config validation fails, exit before starting MCP server
    - If connection test fails, exit before starting MCP server
  </action>
  <verify>
    - `npx tsc` compiles successfully and produces build/index.js
    - `build/index.js` starts with `#!/usr/bin/env node`
    - `grep -r "console.log" src/` returns NO results
    - `grep -r "process.stdout" src/` returns NO results
    - Startup sequence is: loadConfig -> createLogger -> validateConnection -> McpServer -> StdioServerTransport
    - Error catch block calls formatStartupError and process.exit(1)
    - Run `node build/index.js` without env vars -- should exit with clear error about missing DAV_URL
  </verify>
  <done>
    Entry point implements full startup validation flow: config validation (Zod) -> logger init (Pino/stderr) -> CalDAV connection test (tsdav/Basic Auth) -> MCP server start (stdio transport). Invalid config or unreachable server exits with AI-friendly error. No stdout contamination. Server ready for tool registration in Phase 4.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc` compiles the full project without errors
2. `node build/index.js` without env vars exits with error mentioning DAV_URL, DAV_USERNAME, DAV_PASSWORD
3. `DAV_URL=http://example.com DAV_USERNAME=x DAV_PASSWORD=y node build/index.js` exits with HTTPS enforcement error
4. `DAV_URL=http://localhost:8080 DAV_USERNAME=x DAV_PASSWORD=y node build/index.js` accepts localhost (then fails on connection, which is expected)
5. `grep -r "console.log\|process.stdout" src/` returns zero matches
6. All error messages include actionable fix suggestions (not just "Error occurred")
</verification>

<success_criteria>
- Server starts and connects to MCP stdio transport when valid config and reachable CalDAV server provided
- Missing env vars produce error: "Check your environment variables (DAV_URL, DAV_USERNAME, DAV_PASSWORD)"
- HTTP URL (non-localhost) produces error: "URL must use HTTPS"
- Unreachable server produces error with fix suggestion (check URL, check server running)
- Auth failure produces error suggesting credential check
- Zero stdout contamination (no console.log, no process.stdout.write)
- Full TypeScript project compiles cleanly with strict mode
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-configuration/01-02-SUMMARY.md`
</output>
