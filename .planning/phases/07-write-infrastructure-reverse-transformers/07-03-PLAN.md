---
phase: 07-write-infrastructure-reverse-transformers
plan: 03
type: tdd
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/transformers/contact-builder.ts
  - tests/unit/contact-builder.test.ts
autonomous: true

must_haves:
  truths:
    - "buildVCardString produces valid vCard 3.0 with VERSION, FN, N, UID, and all supplied properties"
    - "updateVCardString parses existing vCard, modifies only specified properties, and preserves photos, groups, custom fields, and original vCard version"
    - "FN property is always set from the name parameter"
    - "N property is derived from name by splitting into family/given parts"
  artifacts:
    - path: "src/transformers/contact-builder.ts"
      provides: "buildVCardString and updateVCardString functions"
      exports: ["buildVCardString", "updateVCardString"]
      min_lines: 60
    - path: "tests/unit/contact-builder.test.ts"
      provides: "Unit tests for contact builder functions"
      min_lines: 80
  key_links:
    - from: "src/transformers/contact-builder.ts"
      to: "src/types/dtos.ts"
      via: "imports CreateContactInput, UpdateContactInput"
      pattern: "import.*CreateContactInput.*UpdateContactInput.*from.*dtos"
    - from: "src/transformers/contact-builder.ts"
      to: "ical.js"
      via: "ICAL.Component, ICAL.Property"
      pattern: "import ICAL from 'ical\\.js'"
    - from: "tests/unit/contact-builder.test.ts"
      to: "src/transformers/contact-builder.ts"
      via: "imports buildVCardString, updateVCardString"
      pattern: "import.*buildVCardString.*updateVCardString.*from"
---

<objective>
Build vCard construction (create) and parse-modify-serialize (update) functions with TDD, producing valid vCard output that preserves all properties during round-trips.

Purpose: These functions are the core of write operations for contacts. `buildVCardString` is used by Phase 10's `create_contact` tool, and `updateVCardString` is used by `update_contact`. The update function must preserve photos, groups, custom fields, and the original vCard version (3.0 or 4.0) to prevent silent data loss.

Output: Working, tested `src/transformers/contact-builder.ts` with `buildVCardString()` and `updateVCardString()` functions.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/transformers/contact.ts
@src/types/dtos.ts
@vitest.config.ts
</context>

<feature>
  <name>vCard Contact Builder (build + update)</name>
  <files>src/transformers/contact-builder.ts, tests/unit/contact-builder.test.ts</files>
  <behavior>
**buildVCardString(input: CreateContactInput): string**

Cases:
- Basic contact {name: "John Doe"} -> vCard string containing BEGIN:VCARD, VERSION:3.0, FN:John Doe, N:Doe;John;;; , UID (UUID format), END:VCARD
- With email {name: "John Doe", email: "john@example.com"} -> also contains EMAIL:john@example.com
- With phone {name: "John Doe", phone: "+1-555-1234"} -> also contains TEL:+1-555-1234
- With organization {name: "John Doe", organization: "Acme Corp"} -> also contains ORG:Acme Corp
- With all fields -> vCard string containing all properties
- Single-word name {name: "Madonna"} -> FN:Madonna, N:Madonna;;;; (family name only, no given)
- Output is parseable by ICAL.parse() without errors (round-trip validation)
- Always produces vCard 3.0 (project decision: vCard 3.0 for creates)

**updateVCardString(raw: string, changes: UpdateContactInput): string**

Cases:
- Change name only: raw vCard with FN:Old Name + changes {name: "New Name"} -> output has FN:New Name and updated N property, all other properties identical
- Preserve PHOTO: raw vCard with PHOTO;ENCODING=b;TYPE=JPEG:base64data + any change -> output still contains PHOTO with encoding and data
- Preserve groups: raw vCard with item1.EMAIL:john@example.com and item1.X-ABLABEL:Work -> output preserves grouped properties
- Preserve custom fields: raw vCard with X-CUSTOM-FIELD:value + any change -> output still contains X-CUSTOM-FIELD
- Preserve version: raw vCard 4.0 with VERSION:4.0 + any change -> output still has VERSION:4.0 (not overwritten to 3.0)
- Change email: changes {email: "new@example.com"} -> first EMAIL property updated (or added if none exists)
- Change phone: changes {phone: "+1-555-9999"} -> first TEL property updated (or added if none exists)
- Change organization: changes {organization: "New Corp"} -> ORG property updated
- Undefined fields NOT modified: changes {name: "New"} (no email) -> EMAIL unchanged
  </behavior>
  <implementation>
**buildVCardString implementation:**
1. Import `ICAL` from `ical.js`, `randomUUID` from `node:crypto`, `CreateContactInput` from types
2. Create `ICAL.Component('vcard')`
3. Add `version: '3.0'` (project decision)
4. Add `fn: input.name`
5. Derive N property from name: split by last space -> family name is last word, given name is everything before. For single-word names, family = name, given = empty.
   Create `ICAL.Property('n')`, set value as array `[family, given, '', '', '']`
6. Add `uid: randomUUID()`
7. If email: `vcard.addPropertyWithValue('email', input.email)`
8. If phone: `vcard.addPropertyWithValue('tel', input.phone)`
9. If organization: `vcard.addPropertyWithValue('org', input.organization)`
10. Return `vcard.toString()`

**updateVCardString implementation:**
1. Parse raw with `ICAL.parse(raw)` -> `new ICAL.Component(jCalData)`
2. For each defined field in changes (check `!== undefined`):
   - name: `vcard.updatePropertyWithValue('fn', changes.name)` AND update N property with derived family/given
   - email: find first EMAIL property; if exists, update its value; if not, add new EMAIL property
   - phone: find first TEL property; if exists, update its value; if not, add new TEL property
   - organization: `vcard.updatePropertyWithValue('org', changes.organization)`
3. Return `comp.toString()` -- preserves ALL unmodified properties (PHOTO, groups, X-properties, VERSION)

CRITICAL: Same parse-modify-serialize pattern as event-builder. The `ICAL.Component.toString()` call preserves everything not explicitly changed.

Note on email/phone update strategy: Use `getFirstProperty('email')` to check if one exists. If yes, call `property.setValue(newValue)`. If no, use `addPropertyWithValue()`. This avoids destroying grouped properties (item1.EMAIL) when updating -- only the first EMAIL is replaced.

Note on N property derivation: "John Doe" -> N:Doe;John;;;  "Madonna" -> N:Madonna;;;;  "Jean-Pierre Dupont" -> N:Dupont;Jean-Pierre;;;
Split on LAST space (not first) to handle multi-part given names correctly.

Test file location: `tests/unit/contact-builder.test.ts` (same directory as event-builder tests).
  </implementation>
</feature>

<verification>
1. `npx vitest run tests/unit/contact-builder.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- zero compilation errors
3. Build output of `buildVCardString` is parseable by `ICAL.parse()` (tested in test suite)
4. Update output of `updateVCardString` preserves PHOTO, groups, X-properties, VERSION (tested in test suite)
5. `npm test` -- all tests pass (unit + existing integration)
</verification>

<success_criteria>
- buildVCardString produces valid vCard 3.0 with VERSION, FN, N, UID
- buildVCardString adds EMAIL, TEL, ORG when supplied
- buildVCardString correctly derives N from single-word and multi-word names
- updateVCardString modifies only specified properties, leaving everything else intact
- updateVCardString preserves PHOTO, grouped properties, X-custom fields, and original VERSION
- updateVCardString adds new EMAIL/TEL if none exists, updates first if one exists
- All tests pass, TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-write-infrastructure-reverse-transformers/07-03-SUMMARY.md`
</output>
