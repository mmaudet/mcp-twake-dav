---
phase: 09-calendar-write-tools
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/tools/calendar/update-event.ts
  - src/tools/index.ts
  - tests/integration/tools.test.ts
autonomous: true

must_haves:
  truths:
    - "update_event tool module exists with registerUpdateEventTool export"
    - "update_event finds event by UID, applies parse-modify-serialize on _raw, preserves VALARM and X-properties"
    - "update_event verifies RRULE is preserved after modification on recurring events"
    - "update_event warns about attendees and potential re-invitation emails"
    - "update_event uses If-Match ETag for optimistic concurrency"
    - "All 3 write tools are registered in index.ts and discoverable via MCP"
    - "Integration tests expect 12 tools (9 read + 3 write) with correct names"
  artifacts:
    - path: "src/tools/calendar/update-event.ts"
      provides: "MCP update_event tool registration function"
      exports: ["registerUpdateEventTool"]
      contains: "updateICalString"
    - path: "src/tools/index.ts"
      provides: "Tool registration hub with all 12 tools"
      contains: "registerDeleteEventTool"
    - path: "tests/integration/tools.test.ts"
      provides: "Integration tests validating 12 tool registrations"
      contains: "toHaveLength(12)"
  key_links:
    - from: "src/tools/calendar/update-event.ts"
      to: "src/caldav/calendar-service.ts"
      via: "calendarService.findEventByUid() then calendarService.updateEvent()"
      pattern: "calendarService\\.findEventByUid|calendarService\\.updateEvent"
    - from: "src/tools/calendar/update-event.ts"
      to: "src/transformers/event-builder.ts"
      via: "updateICalString() for parse-modify-serialize on _raw"
      pattern: "updateICalString"
    - from: "src/tools/index.ts"
      to: "src/tools/calendar/delete-event.ts"
      via: "import and call registerDeleteEventTool"
      pattern: "registerDeleteEventTool"
    - from: "src/tools/index.ts"
      to: "src/tools/calendar/create-event.ts"
      via: "import and call registerCreateEventTool"
      pattern: "registerCreateEventTool"
    - from: "src/tools/index.ts"
      to: "src/tools/calendar/update-event.ts"
      via: "import and call registerUpdateEventTool"
      pattern: "registerUpdateEventTool"
---

<objective>
Create the update_event MCP tool, wire all 3 calendar write tools into the tool registry, and update integration tests.

Purpose: The update_event tool (CALW-02) is the most complex write tool -- it must find an event by UID, apply parse-modify-serialize on the raw iCalendar to preserve VALARM/X-properties/ATTENDEE, verify RRULE preservation on recurring events, and handle ETag-based conflict detection. After creating this tool, all 3 calendar write tools are registered in index.ts, and integration tests are updated to expect 12 tools total.

Output: Complete calendar write tool suite (3 tools) registered and tested.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 01 artifacts (created in previous plan)
@src/tools/calendar/delete-event.ts
@src/tools/calendar/create-event.ts

# Existing tool pattern and registry
@src/tools/calendar/next-event.ts
@src/tools/index.ts

# Service methods and builder
@src/caldav/calendar-service.ts
@src/transformers/event-builder.ts

# Types, errors, and tests
@src/types/dtos.ts
@src/errors.ts
@tests/integration/tools.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update_event MCP tool</name>
  <files>src/tools/calendar/update-event.ts</files>
  <action>
Create `src/tools/calendar/update-event.ts` exporting `registerUpdateEventTool(server, calendarService, logger, defaultCalendar?)`.

Follow the exact pattern from `next-event.ts` for function signature and error handling structure.

Tool registration:
- Name: `update_event`
- Description: `"Update an existing calendar event by UID. Modifies only the specified fields while preserving all other properties (alarms, attendees, custom fields). IMPORTANT: Confirm with the user before proceeding. Show the user what will change and ask them to confirm before updating."`
- Parameters (using zod):
  - `uid`: `z.string().describe('The UID of the event to update. Use search_events or get_todays_schedule to find event UIDs.')` -- REQUIRED
  - `title`: `z.string().optional().describe('New event title/summary')` -- optional
  - `start`: `z.string().optional().describe('New start date/time. Supports natural language (e.g., "tomorrow at 3pm") or ISO 8601 format.')` -- optional
  - `end`: `z.string().optional().describe('New end date/time. Supports natural language or ISO 8601 format.')` -- optional
  - `description`: `z.string().optional().describe('New event description')` -- optional
  - `location`: `z.string().optional().describe('New event location')` -- optional
  - `calendar`: `z.string().optional().describe('Calendar name to search in. Defaults to ...')` -- same defaultCalendar pattern

Implementation flow:
1. Log params at debug level
2. Check that at least one field to update is provided (title, start, end, description, or location). If none provided, return error: "No changes specified. Provide at least one field to update (title, start, end, description, location)."
3. Resolve calendar: if params.calendar is "all" use undefined, else use params.calendar || defaultCalendar || undefined
4. Call `calendarService.findEventByUid(params.uid, resolvedCalendar)`
5. If not found, return `{ content: [{ type: 'text', text: 'Event not found with UID: ...' }], isError: true }`
6. Build UpdateEventInput object. For start and end fields, parse dates:
   - If params.start provided: `chrono.parseDate(params.start)` first, fallback to `new Date(params.start)`, validate not NaN
   - If params.end provided: same approach
   - If start is updated but end is not, and the new start is after the existing end, return error: "New start time is after the existing end time. Please also update the end time."
7. RRULE safety check: if the found event is recurring (event.isRecurring === true), store the RRULE string before update: `const originalRrule = event.recurrenceRule`
8. Call `updateICalString(event._raw, changes)` to get updated iCalendar string
9. RRULE verification: If event was recurring, parse the updated iCalendar with ICAL.parse, get VEVENT, check that rrule property still exists. If RRULE is missing after update, throw an Error: "RRULE was lost during update. This is a bug -- please report it."
10. Warn about attendees: if event.attendees.length > 0, include warning text: "Note: This event has attendees (${event.attendees.join(', ')}). The server may send update notifications to all attendees."
11. Call `calendarService.updateEvent(event.url, updatedICalString, event.etag!)` -- etag should always exist from findEventByUid
12. Return success text: "Event updated successfully: ${event.summary}\nChanges: ${list of changed fields}\n${attendeeWarning || ''}"
13. Wrap in try/catch. In catch block:
    - If `err instanceof ConflictError`, return `{ content: [{ type: 'text', text: err.message }], isError: true }`
    - Otherwise, standard error pattern

Imports needed: `z` from 'zod', `McpServer` type, `Logger` type, `CalendarService` type, `ConflictError` from '../../errors.js', `updateICalString` from '../../transformers/event-builder.js', `* as chrono` from 'chrono-node', `ICAL` from 'ical.js' (for RRULE verification).

IMPORTANT anti-patterns to avoid:
- Do NOT build iCalendar from scratch for updates (use updateICalString which parses _raw)
- Do NOT pass undefined etag to updateEvent (findEventByUid returns etag)
- Do NOT add attendees parameter (v2 decision: no attendees)
- Do NOT add recurrence parameter to update tool (modifying RRULE on existing events is too risky for v2 -- simple recurring only)
  </action>
  <verify>
Run `npx tsc --noEmit` -- the file should compile without type errors.
Verify the file exports `registerUpdateEventTool` function.
Verify RRULE safety check is present (grep for "rrule" in the file).
  </verify>
  <done>
`src/tools/calendar/update-event.ts` exists, exports registerUpdateEventTool, compiles cleanly, uses findEventByUid + updateICalString + updateEvent, includes RRULE preservation check, warns about attendees, handles ConflictError, and tool description contains "IMPORTANT: Confirm with the user before proceeding".
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire all 3 write tools into registry and update tests</name>
  <files>src/tools/index.ts, tests/integration/tools.test.ts</files>
  <action>
**Part A: Update `src/tools/index.ts`**

1. Add imports at the top (after existing calendar tool imports):
   ```
   import { registerDeleteEventTool } from './calendar/delete-event.js';
   import { registerCreateEventTool } from './calendar/create-event.js';
   import { registerUpdateEventTool } from './calendar/update-event.js';
   ```

2. Add registration calls inside `registerAllTools()` function, AFTER the existing calendar query tools section and BEFORE the contact query tools section. Add a new comment section:
   ```
   // Register calendar write tools (Phase 9)
   registerDeleteEventTool(server, calendarService, logger, defaultCalendar);
   registerCreateEventTool(server, calendarService, logger, defaultCalendar);
   registerUpdateEventTool(server, calendarService, logger, defaultCalendar);
   ```

3. Update the JSDoc comment at the top of the file to mention Phase 9 calendar write tools.

**Part B: Update `tests/integration/tools.test.ts`**

1. Update the tool count test: change `toHaveLength(9)` to `toHaveLength(12)` (9 existing + 3 new write tools)

2. Update the tool names test: add `'create_event'`, `'delete_event'`, and `'update_event'` to the `expectedNames` array. Keep the array alphabetically sorted.

3. Add new test cases for the 3 write tools (follow the pattern of existing tool parameter tests):

   - Test for `create_event`: verify it has `title`, `start`, `end` in properties, and that `title`, `start`, `end` are in the required array.

   - Test for `update_event`: verify it has `uid` in properties, and that `uid` is in the required array. Verify it has optional fields `title`, `start`, `end`, `description`, `location`.

   - Test for `delete_event`: verify it has `uid` in properties, and that `uid` is in the required array. Verify it has optional `calendar` property.

4. Add a test that all 3 write tool descriptions contain "IMPORTANT":
   ```
   it('should include confirmation instruction in all write tool descriptions', async () => {
     const response = await client.listTools();
     const writeToolNames = ['create_event', 'update_event', 'delete_event'];
     for (const name of writeToolNames) {
       const tool = response.tools.find(t => t.name === name);
       expect(tool).toBeDefined();
       expect(tool!.description).toContain('IMPORTANT');
     }
   });
   ```
  </action>
  <verify>
Run `npx tsc --noEmit` -- full project compiles.
Run `npx vitest run` -- all tests pass including new tool registration tests.
Verify 12 tools are registered by checking the test output.
  </verify>
  <done>
`src/tools/index.ts` imports and registers all 3 calendar write tools (registerDeleteEventTool, registerCreateEventTool, registerUpdateEventTool). Integration tests pass with 12 tools expected, correct tool names, write tool parameter schemas validated, and IMPORTANT confirmation text verified in all write tool descriptions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (all 3 new tool files + updated index.ts compile)
2. `npx vitest run` passes (12 tools registered, names correct, schemas validated)
3. update_event uses parse-modify-serialize via updateICalString (not building from scratch)
4. update_event has RRULE safety check (verifies RRULE preserved after modification)
5. update_event warns about attendees if event has them
6. All 3 write tools handle ConflictError
7. All 3 tool descriptions contain "IMPORTANT: Confirm with the user before proceeding"
8. Tool count is now 12 (9 read + 3 write)
</verification>

<success_criteria>
- update_event.ts exists with complete find-by-UID, parse-modify-serialize, RRULE safety, attendee warning, and conflict handling
- index.ts registers all 3 calendar write tools (delete_event, create_event, update_event)
- Integration tests pass with 12 tools, correct names, validated schemas
- All write tool descriptions include AI-guided confirmation text
- Full TypeScript compilation succeeds
- Round-trip possible: create -> (read via existing tools) -> update -> (read) -> delete
</success_criteria>

<output>
After completion, create `.planning/phases/09-calendar-write-tools/09-02-SUMMARY.md`
</output>
