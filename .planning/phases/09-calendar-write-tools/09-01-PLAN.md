---
phase: 09-calendar-write-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/calendar/delete-event.ts
  - src/tools/calendar/create-event.ts
autonomous: true

must_haves:
  truths:
    - "delete_event tool module exists with registerDeleteEventTool export"
    - "create_event tool module exists with registerCreateEventTool export"
    - "delete_event accepts uid (required) and calendar (optional) parameters"
    - "create_event accepts title, start, end (required) plus description, location, calendar, allDay, recurrence (optional)"
    - "Both tool descriptions include IMPORTANT confirm instruction"
    - "delete_event warns about attendees and potential cancellation emails"
    - "create_event supports natural language dates via chrono-node"
  artifacts:
    - path: "src/tools/calendar/delete-event.ts"
      provides: "MCP delete_event tool registration function"
      exports: ["registerDeleteEventTool"]
      contains: "destructiveHint"
    - path: "src/tools/calendar/create-event.ts"
      provides: "MCP create_event tool registration function"
      exports: ["registerCreateEventTool"]
      contains: "chrono"
  key_links:
    - from: "src/tools/calendar/delete-event.ts"
      to: "src/caldav/calendar-service.ts"
      via: "calendarService.findEventByUid() then calendarService.deleteEvent()"
      pattern: "calendarService\\.findEventByUid|calendarService\\.deleteEvent"
    - from: "src/tools/calendar/create-event.ts"
      to: "src/transformers/event-builder.ts"
      via: "buildICalString() to construct iCalendar then calendarService.createEvent()"
      pattern: "buildICalString|calendarService\\.createEvent"
    - from: "src/tools/calendar/create-event.ts"
      to: "src/tools/calendar/utils.ts"
      via: "chrono-node date parsing for natural language start/end"
      pattern: "chrono\\.parseDate|chrono\\.parse"
---

<objective>
Create the delete_event and create_event MCP tool modules for calendar write operations.

Purpose: These two tools (CALW-03 and CALW-01) enable users to delete and create calendar events through the AI assistant. Delete is the simplest write tool; create requires natural language date parsing and iCalendar construction. Both tools are created as standalone modules that will be wired into the tool registry in Plan 02.

Output: Two new tool files ready for registration -- `delete-event.ts` and `create-event.ts`.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing tool pattern to follow
@src/tools/calendar/next-event.ts
@src/tools/calendar/utils.ts

# Service methods these tools call
@src/caldav/calendar-service.ts

# Builder for create_event
@src/transformers/event-builder.ts

# Types and errors
@src/types/dtos.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delete_event MCP tool</name>
  <files>src/tools/calendar/delete-event.ts</files>
  <action>
Create `src/tools/calendar/delete-event.ts` exporting `registerDeleteEventTool(server, calendarService, logger, defaultCalendar?)`.

Follow the exact pattern from `next-event.ts` for function signature and error handling structure.

Tool registration:
- Name: `delete_event`
- Description: `"Delete a calendar event by its UID. Removes the event from the CalDAV server permanently. IMPORTANT: Confirm with the user before proceeding. If the event has attendees, warn the user that the server may send cancellation emails to all attendees."`
- Parameters (using zod):
  - `uid`: `z.string().describe('The UID of the event to delete. Use search_events or get_todays_schedule to find event UIDs.')` -- REQUIRED
  - `calendar`: `z.string().optional().describe('Calendar name to search in. Defaults to ...')` -- same defaultCalendar pattern as existing tools

Implementation flow:
1. Log params at debug level
2. Call `calendarService.findEventByUid(params.uid, resolvedCalendar)` where resolvedCalendar applies the same default calendar logic: if params.calendar is "all" use undefined, else use params.calendar || defaultCalendar || undefined
3. If not found, return `{ content: [{ type: 'text', text: 'Event not found with UID: ...' }], isError: true }`
4. Check if event has attendees (event.attendees.length > 0). If yes, include a warning line in the response: `"Warning: This event has attendees (${event.attendees.join(', ')}). The server may send cancellation emails to all attendees."`
5. Call `calendarService.deleteEvent(event.url, event.etag)`
6. Return success text: `"Event deleted successfully: ${event.summary}\n${attendeeWarning || ''}"`
7. Wrap in try/catch. In catch block:
   - If `err instanceof ConflictError`, return `{ content: [{ type: 'text', text: err.message }], isError: true }`
   - Otherwise, use standard error pattern from existing tools

Imports needed: `z` from 'zod', `McpServer` type, `Logger` type, `CalendarService` type, `ConflictError` from '../../errors.js'.

Do NOT import or use chrono-node in this file (not needed for delete).
  </action>
  <verify>
Run `npx tsc --noEmit` -- the file should compile without type errors.
Verify the file exports `registerDeleteEventTool` function.
  </verify>
  <done>
`src/tools/calendar/delete-event.ts` exists, exports registerDeleteEventTool, compiles cleanly, uses findEventByUid + deleteEvent service methods, includes attendee warning logic, and tool description contains "IMPORTANT: Confirm with the user before proceeding".
  </done>
</task>

<task type="auto">
  <name>Task 2: Create create_event MCP tool</name>
  <files>src/tools/calendar/create-event.ts</files>
  <action>
Create `src/tools/calendar/create-event.ts` exporting `registerCreateEventTool(server, calendarService, logger, defaultCalendar?)`.

Follow the exact pattern from `next-event.ts` for function signature and error handling structure.

Tool registration:
- Name: `create_event`
- Description: `"Create a new calendar event. Supports natural language dates (e.g., 'tomorrow at 2pm', 'next Monday'). IMPORTANT: Confirm with the user before proceeding. Summarize the event details (title, start, end, location) and ask the user to confirm before creating."`
- Parameters (using zod):
  - `title`: `z.string().describe('Event title/summary')` -- REQUIRED
  - `start`: `z.string().describe('Start date/time. Supports natural language (e.g., "tomorrow at 2pm", "next Monday at 10am") or ISO 8601 format.')` -- REQUIRED
  - `end`: `z.string().describe('End date/time. Supports natural language or ISO 8601 format. If not specified as a time, defaults to 1 hour after start.')` -- REQUIRED
  - `description`: `z.string().optional().describe('Event description')` -- optional
  - `location`: `z.string().optional().describe('Event location')` -- optional
  - `calendar`: `z.string().optional().describe('Calendar name to create the event in. Defaults to ...')` -- same defaultCalendar pattern
  - `allDay`: `z.boolean().optional().describe('If true, creates an all-day event (DATE format instead of DATE-TIME)')` -- optional
  - `recurrence`: `z.string().optional().describe('RRULE recurrence string (e.g., "FREQ=WEEKLY;BYDAY=MO", "FREQ=DAILY;COUNT=5")')` -- optional

Implementation flow:
1. Log params at debug level
2. Parse start date: first try `chrono.parseDate(params.start)`, if null try `new Date(params.start)`, if still invalid (isNaN) return error "Could not parse start date: ..."
3. Parse end date: same approach with `chrono.parseDate(params.end)`. If null and start parsed successfully, default to 1 hour after start.
4. Validate: end must be after start. If not, return error "End date must be after start date".
5. Resolve target calendar: if params.calendar provided use it, else use defaultCalendar (do NOT pass undefined to createEvent if defaultCalendar exists -- pass it as calendarName).
6. Build iCalendar string: call `buildICalString({ title: params.title, start: startDate, end: endDate, description: params.description, location: params.location, allDay: params.allDay, recurrence: params.recurrence })`
7. Call `calendarService.createEvent(iCalString, resolvedCalendar)`
8. Return success text including: event title, start/end formatted nicely (use `startDate.toLocaleString()` or similar), location if provided, calendar name if resolved
9. Wrap in try/catch. In catch block:
   - If `err instanceof ConflictError`, return `{ content: [{ type: 'text', text: err.message }], isError: true }`
   - Otherwise, standard error pattern

Imports needed: `z` from 'zod', `McpServer` type, `Logger` type, `CalendarService` type, `ConflictError` from '../../errors.js', `buildICalString` from '../../transformers/event-builder.js', `* as chrono` from 'chrono-node'.

IMPORTANT: Use `import * as chrono from 'chrono-node'` (the established import pattern from utils.ts). Use `chrono.parseDate()` for single-date parsing (not `chrono.parse()`).

Do NOT add attendees parameter (decision: no attendees in v2 due to SabreDAV scheduling side-effects).
  </action>
  <verify>
Run `npx tsc --noEmit` -- the file should compile without type errors.
Verify the file exports `registerCreateEventTool` function.
Verify chrono-node is imported for natural language date parsing.
  </verify>
  <done>
`src/tools/calendar/create-event.ts` exists, exports registerCreateEventTool, compiles cleanly, uses chrono-node for natural language date parsing, calls buildICalString + calendarService.createEvent, supports all 8 parameters (title, start, end, description, location, calendar, allDay, recurrence), and tool description contains "IMPORTANT: Confirm with the user before proceeding".
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (both new files compile)
2. Both files export their register functions
3. Both tool descriptions include "IMPORTANT: Confirm with the user before proceeding"
4. delete-event.ts uses findEventByUid + deleteEvent, handles ConflictError, warns about attendees
5. create-event.ts uses chrono-node + buildICalString + createEvent, handles ConflictError
</verification>

<success_criteria>
- Two new tool files exist at `src/tools/calendar/delete-event.ts` and `src/tools/calendar/create-event.ts`
- TypeScript compilation succeeds with no errors
- Both tools follow the established tool registration pattern from Phase 4
- delete_event: finds by UID, warns about attendees, deletes with ETag conflict handling
- create_event: parses natural language dates, builds iCalendar, creates with duplicate UID conflict handling
- Both descriptions contain AI-guided confirmation text
</success_criteria>

<output>
After completion, create `.planning/phases/09-calendar-write-tools/09-01-SUMMARY.md`
</output>
