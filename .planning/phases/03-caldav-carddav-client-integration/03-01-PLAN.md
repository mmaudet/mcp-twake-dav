---
phase: 03-caldav-carddav-client-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/caldav/retry.ts
  - src/types/cache.ts
  - src/caldav/cache.ts
autonomous: true

must_haves:
  truths:
    - "Failed network operations are retried up to 3 times with exponential backoff"
    - "Jitter prevents thundering herd on retry delays"
    - "Cache stores objects keyed by collection URL with CTag for invalidation"
    - "Cache returns cached objects when CTag is unchanged"
    - "Cache re-fetches when CTag changes or is missing"
  artifacts:
    - path: "src/caldav/retry.ts"
      provides: "Generic async retry with exponential backoff and jitter"
      exports: ["withRetry", "RetryOptions"]
    - path: "src/types/cache.ts"
      provides: "CacheEntry and CollectionCache type definitions"
      exports: ["CacheEntry", "CollectionCacheOptions"]
    - path: "src/caldav/cache.ts"
      provides: "In-memory CTag-based collection cache"
      exports: ["CollectionCache"]
  key_links:
    - from: "src/caldav/retry.ts"
      to: "pino Logger"
      via: "Logger parameter for warning on retry attempts"
      pattern: "logger\\.warn"
    - from: "src/caldav/cache.ts"
      to: "src/types/cache.ts"
      via: "imports CacheEntry type"
      pattern: "import.*CacheEntry.*cache\\.js"
    - from: "src/caldav/cache.ts"
      to: "tsdav isCollectionDirty"
      via: "uses client.isCollectionDirty for CTag comparison"
      pattern: "isCollectionDirty"
---

<objective>
Create the retry utility and CTag-based caching infrastructure that calendar and addressbook services will use.

Purpose: These are shared foundations -- retry ensures resilience against transient network failures (requirement INF-04 connection error handling), and the collection cache implements CTag-based invalidation for performance (requirement INF-04 ETag/CTag caching).

Output: Three files providing reusable retry logic, cache type definitions, and an in-memory collection cache with CTag dirty-checking.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-caldav-carddav-client-integration/03-RESEARCH.md

@src/config/logger.ts
@src/caldav/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create retry utility and cache types</name>
  <files>src/caldav/retry.ts, src/types/cache.ts</files>
  <action>
Create `src/caldav/retry.ts`:

Export a `RetryOptions` interface:
- `maxAttempts: number` (default 3)
- `baseDelayMs: number` (default 1000)
- `maxDelayMs: number` (default 10000)
- `jitter: boolean` (default true)

Export an async function `withRetry<T>(fn: () => Promise<T>, logger: Logger, options?: Partial<RetryOptions>): Promise<T>`:
- Loop from attempt 1 to maxAttempts
- On each attempt, call `fn()` and return result on success
- On failure, if this was the last attempt, re-throw the error
- Otherwise, compute delay: `Math.min(baseDelayMs * Math.pow(2, attempt - 1), maxDelayMs)`
- If jitter enabled, multiply delay by `(0.5 + Math.random() * 0.5)`
- Log a warning with `{ attempt, maxAttempts, delayMs: Math.round(jitteredDelay), err: error }`
- Await `setTimeout` promise for the computed delay
- After loop, throw `new Error('withRetry: all attempts exhausted')` for TypeScript exhaustiveness

Import Logger from `pino` (type-only), NOT from `../config/logger.js`. Use `import type { Logger } from 'pino';` to match existing transformer patterns.

Use `.js` extension on all local imports. No console.log.

---

Create `src/types/cache.ts`:

Export a `CacheEntry<T>` generic interface:
- `ctag: string` -- the CTag value at time of caching
- `objects: T[]` -- the cached objects
- `lastFetched: number` -- Date.now() timestamp of last fetch

Export a `CollectionCacheOptions` interface:
- `maxAgeMs?: number` -- optional TTL for cache entries (default: no TTL, rely on CTag only)

No imports needed for this file (pure type definitions).
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors in the new files.
  </verify>
  <done>
`src/caldav/retry.ts` exports withRetry and RetryOptions. `src/types/cache.ts` exports CacheEntry and CollectionCacheOptions. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CTag-based collection cache</name>
  <files>src/caldav/cache.ts</files>
  <action>
Create `src/caldav/cache.ts`:

Import `type { Logger } from 'pino'`.
Import `type { CacheEntry } from '../types/cache.js'`.

Export a class `CollectionCache<T>`:

**Constructor:** Takes `logger: Logger` parameter. Stores it as private field. Creates a private `cache: Map<string, CacheEntry<T>>`.

**Method `get(collectionUrl: string): CacheEntry<T> | undefined`:**
- Returns the cached entry for the given URL, or undefined.

**Method `set(collectionUrl: string, ctag: string, objects: T[]): void`:**
- Stores a new CacheEntry with the given ctag, objects, and `lastFetched: Date.now()`.
- Logs at debug level: `{ url: collectionUrl, objectCount: objects.length, ctag }`, message "Cache updated for collection".

**Method `isFresh(collectionUrl: string, currentCtag: string | undefined): boolean`:**
- If `currentCtag` is undefined or empty, return false (CTag not supported, always re-fetch).
- Gets the cached entry. If no entry exists, return false.
- Returns `cached.ctag === currentCtag`.

**Method `invalidate(collectionUrl: string): void`:**
- Deletes the entry for the URL from the map.

**Method `clear(): void`:**
- Clears the entire map.

**Method `size(): number`:**
- Returns the map size.

IMPORTANT: This cache does NOT call tsdav directly. It is a passive data store. The services (Plan 03, Plan 04) will call `isCollectionDirty()` and then use this cache's `isFresh()` / `get()` / `set()` methods. This keeps the cache generic and testable.

Use `.js` extension on all local imports. No console.log.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors. Verify the class exports correctly by checking the build output.
  </verify>
  <done>
`src/caldav/cache.ts` exports a `CollectionCache<T>` class with get/set/isFresh/invalidate/clear/size methods. CTag comparison logic is correct. File compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` succeeds with zero errors
2. `src/caldav/retry.ts` exists with exported `withRetry` function and `RetryOptions` interface
3. `src/types/cache.ts` exists with exported `CacheEntry<T>` and `CollectionCacheOptions`
4. `src/caldav/cache.ts` exists with exported `CollectionCache<T>` class
5. All imports use `.js` extensions
6. No `console.log` in any file -- logger only
7. No stdout contamination patterns
</verification>

<success_criteria>
- Three new files compile without TypeScript errors
- withRetry implements exponential backoff with jitter and configurable max attempts
- CollectionCache provides CTag-based freshness checking via isFresh() method
- All files follow ESM conventions with .js import extensions
- Logger imported from 'pino' (type-only) matching existing codebase patterns
</success_criteria>

<output>
After completion, create `.planning/phases/03-caldav-carddav-client-integration/03-01-SUMMARY.md`
</output>
