---
phase: 03-caldav-carddav-client-integration
plan: 05
type: execute
wave: 3
depends_on: [03-02, 03-03, 03-04]
files_modified:
  - src/caldav/client.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Server startup creates both CalDAV and CardDAV clients"
    - "Startup validates connection by discovering at least one calendar OR address book"
    - "CalendarService and AddressBookService are initialized and available to MCP server"
    - "Startup failure produces AI-friendly error messages for both CalDAV and CardDAV"
    - "Existing MCP server initialization and stdio transport are preserved"
  artifacts:
    - path: "src/caldav/client.ts"
      provides: "Updated validateDualConnection function for dual-client validation"
      exports: ["createCalDAVClient", "createCardDAVClient", "createDualClients", "validateDualConnection", "DualClients", "DAVClientType"]
    - path: "src/index.ts"
      provides: "Updated startup flow using dual clients, CalendarService, and AddressBookService"
  key_links:
    - from: "src/index.ts"
      to: "src/caldav/client.ts"
      via: "calls createDualClients and validateDualConnection at startup"
      pattern: "createDualClients|validateDualConnection"
    - from: "src/index.ts"
      to: "src/caldav/calendar-service.ts"
      via: "creates CalendarService instance with CalDAV client"
      pattern: "new CalendarService"
    - from: "src/index.ts"
      to: "src/caldav/addressbook-service.ts"
      via: "creates AddressBookService instance with CardDAV client"
      pattern: "new AddressBookService"
    - from: "src/caldav/client.ts"
      to: "src/caldav/discovery.ts"
      via: "validateDualConnection uses discoverCalendars and discoverAddressBooks"
      pattern: "discoverCalendars|discoverAddressBooks"
---

<objective>
Wire the dual-client architecture and services into the application startup flow.

Purpose: This plan connects everything built in Plans 01-04 into the running application. The server must create both CalDAV and CardDAV clients, validate the connection by discovering calendars and address books, initialize the service layer, and make services available for Phase 4 and Phase 5 MCP tool registration.

Output: Updated `client.ts` with dual-client validation and updated `index.ts` with the full Phase 3 startup flow.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-caldav-carddav-client-integration/03-RESEARCH.md

@src/caldav/client.ts
@src/index.ts
@src/errors.ts
@src/config/schema.ts
@src/config/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual-client validation to client.ts</name>
  <files>src/caldav/client.ts</files>
  <action>
Modify `src/caldav/client.ts` to add a `validateDualConnection` function.

ADD import for discovery functions:
```typescript
import { discoverCalendars, discoverAddressBooks } from './discovery.js';
```

ADD a new exported async function `validateDualConnection`:
```typescript
export async function validateDualConnection(
  clients: DualClients,
  config: Config,
  logger: Logger
): Promise<{ calendarCount: number; addressBookCount: number }> {
  logger.info({ url: config.DAV_URL }, 'Validating CalDAV and CardDAV connections...');

  // Create a 15-second timeout promise (longer than Phase 1's 10s because we're doing 2 discoveries)
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => {
      reject(new Error('Connection timeout after 15 seconds'));
    }, 15000);
  });

  try {
    // Discover calendars and address books in parallel, with timeout
    const [calendars, addressBooks] = await Promise.race([
      Promise.all([
        discoverCalendars(clients.caldav, logger),
        discoverAddressBooks(clients.carddav, logger),
      ]),
      timeoutPromise,
    ]) as [any[], any[]];

    const calendarCount = calendars.length;
    const addressBookCount = addressBooks.length;

    logger.info(
      { calendarCount, addressBookCount, url: config.DAV_URL },
      'CalDAV/CardDAV connection validated successfully'
    );

    return { calendarCount, addressBookCount };
  } catch (error) {
    // Let the error bubble up to be handled by formatStartupError
    throw error;
  }
}
```

KEEP existing `validateConnection` function -- it still works and could be useful as a simpler single-protocol check. Do NOT delete it.

Use `.js` extension on all local imports. No console.log.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors. Verify both `validateConnection` and `validateDualConnection` are exported.
  </verify>
  <done>
`src/caldav/client.ts` exports `validateDualConnection` alongside all existing exports. Dual validation discovers calendars and address books in parallel with 15-second timeout. File compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update index.ts for dual-client startup flow</name>
  <files>src/index.ts</files>
  <action>
Modify `src/index.ts` to use the dual-client architecture:

UPDATE imports:
```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { loadConfig } from './config/schema.js';
import { createLogger } from './config/logger.js';
import { createDualClients, validateDualConnection } from './caldav/client.js';
import { CalendarService } from './caldav/calendar-service.js';
import { AddressBookService } from './caldav/addressbook-service.js';
import { formatStartupError } from './errors.js';
```

Note: Remove the old `validateConnection` import. Replace with `createDualClients` and `validateDualConnection`.

UPDATE the main function startup sequence:

```typescript
async function main() {
  let davUrl: string | undefined;

  try {
    // Step 1: Load and validate configuration
    const config = loadConfig();
    davUrl = config.DAV_URL;

    // Step 2: Initialize logger (uses config.LOG_LEVEL)
    const logger = createLogger(config.LOG_LEVEL);
    logger.info({ version: '0.1.0' }, 'Starting mcp-twake server');

    // Step 3: Create dual CalDAV/CardDAV clients
    const clients = await createDualClients(config, logger);

    // Step 4: Validate connection (discovers calendars + address books)
    const { calendarCount, addressBookCount } = await validateDualConnection(clients, config, logger);
    logger.info({ calendarCount, addressBookCount }, 'CalDAV/CardDAV clients ready');

    // Step 5: Initialize services
    const calendarService = new CalendarService(clients.caldav, logger);
    const addressBookService = new AddressBookService(clients.carddav, logger);
    logger.info('Calendar and AddressBook services initialized');

    // Step 6: Initialize MCP server
    const server = new McpServer({
      name: 'mcp-twake',
      version: '0.1.0',
    });

    // TODO (Phase 4/5): Register MCP tools using calendarService and addressBookService
    logger.info('MCP server initialized');

    // Step 7: Connect stdio transport
    const transport = new StdioServerTransport();
    await server.connect(transport);

    logger.info('MCP server connected via stdio transport');
  } catch (error) {
    // Format error with AI-friendly message and exit
    const errorMessage = formatStartupError(
      error instanceof Error ? error : new Error(String(error)),
      davUrl
    );
    console.error(`\n${errorMessage}\n`);
    process.exit(1);
  }
}
```

IMPORTANT: The `calendarService` and `addressBookService` variables are created but not yet wired into MCP tools. That happens in Phase 4 and Phase 5. Leave the TODO comment to mark where tool registration will go.

The shebang line `#!/usr/bin/env node` MUST be preserved at the top of the file.

CRITICAL: `console.error` in the catch block is intentional -- it's the startup error output that goes to stderr. This is NOT a logging statement.

Use `.js` extension on all local imports.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors. Verify the startup flow compiles correctly with all new imports.
  </verify>
  <done>
`src/index.ts` creates dual clients, validates connection by discovering calendars and address books, initializes CalendarService and AddressBookService, and starts the MCP server. All existing functionality preserved (config validation, logger, MCP server, stdio transport, error handling). File compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` succeeds with zero errors
2. `src/index.ts` imports createDualClients, validateDualConnection, CalendarService, AddressBookService
3. Startup creates both CalDAV and CardDAV clients via createDualClients
4. Connection validation discovers calendars AND address books
5. CalendarService initialized with CalDAV client
6. AddressBookService initialized with CardDAV client
7. MCP server and stdio transport still initialized correctly
8. Error handling still uses formatStartupError
9. Shebang line preserved
10. All imports use `.js` extensions
11. No stdout contamination -- only stderr logging
</verification>

<success_criteria>
- Server startup creates dual CalDAV/CardDAV clients from same credentials
- Connection validation tests both protocols (discovers calendars + address books)
- CalendarService and AddressBookService instantiated and ready for Phase 4/5 tool registration
- Startup failure produces clear, AI-friendly error messages
- MCP server + stdio transport work as before
- 15-second timeout protects against unresponsive servers
</success_criteria>

<output>
After completion, create `.planning/phases/03-caldav-carddav-client-integration/03-05-SUMMARY.md`
</output>
