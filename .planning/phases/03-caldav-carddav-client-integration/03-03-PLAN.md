---
phase: 03-caldav-carddav-client-integration
plan: 03
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - src/caldav/calendar-service.ts
autonomous: true

must_haves:
  truths:
    - "All calendars for the authenticated user can be listed with display names"
    - "Calendar objects (events) can be fetched from a single calendar"
    - "Calendar objects can be fetched from ALL calendars (multi-calendar aggregation)"
    - "Time-range filtering narrows server-side fetched events"
    - "CTag cache prevents re-fetching unchanged calendars"
    - "Network failures trigger retry with exponential backoff"
    - "Fetched DAVCalendarObjects include url, etag, and raw data fields"
  artifacts:
    - path: "src/caldav/calendar-service.ts"
      provides: "CalendarService class with listCalendars, fetchEvents, fetchAllEvents methods"
      exports: ["CalendarService"]
  key_links:
    - from: "src/caldav/calendar-service.ts"
      to: "src/caldav/client.ts"
      via: "uses DAVClientType for tsdav operations"
      pattern: "import.*DAVClientType.*client\\.js"
    - from: "src/caldav/calendar-service.ts"
      to: "src/caldav/cache.ts"
      via: "uses CollectionCache for CTag-based caching"
      pattern: "import.*CollectionCache.*cache\\.js"
    - from: "src/caldav/calendar-service.ts"
      to: "src/caldav/retry.ts"
      via: "wraps tsdav calls in withRetry"
      pattern: "import.*withRetry.*retry\\.js"
    - from: "src/caldav/calendar-service.ts"
      to: "src/caldav/discovery.ts"
      via: "uses discoverCalendars for initial calendar listing"
      pattern: "import.*discoverCalendars.*discovery\\.js"
    - from: "src/caldav/calendar-service.ts"
      to: "tsdav fetchCalendarObjects"
      via: "calls client.fetchCalendarObjects with optional timeRange"
      pattern: "fetchCalendarObjects"
    - from: "src/caldav/calendar-service.ts"
      to: "tsdav isCollectionDirty"
      via: "checks CTag before re-fetching cached calendar objects"
      pattern: "isCollectionDirty"
---

<objective>
Create the calendar service that fetches calendars and calendar objects with caching and retry.

Purpose: This service implements requirements CAL-05 (list calendars) and CAL-06 (multi-calendar query) by wrapping tsdav's calendar operations with CTag-based caching (INF-04) and retry logic. It returns raw DAVCalendarObject arrays -- transformation into EventDTOs will happen in Phase 4's query layer.

Output: A CalendarService class that Phase 4 and Phase 5 (index.ts wiring) will use.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-caldav-carddav-client-integration/03-RESEARCH.md

@src/caldav/client.ts
@src/types/dtos.ts
@src/transformers/event.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CalendarService class</name>
  <files>src/caldav/calendar-service.ts</files>
  <action>
Create `src/caldav/calendar-service.ts`:

Imports:
- `type { Logger } from 'pino'`
- `type { DAVCalendar, DAVCalendarObject } from 'tsdav'`
- `type { DAVClientType } from './client.js'`
- `{ CollectionCache } from './cache.js'`
- `{ withRetry } from './retry.js'`
- `{ discoverCalendars } from './discovery.js'`

Export a `TimeRange` interface:
```typescript
export interface TimeRange {
  start: string;  // ISO 8601 format
  end: string;    // ISO 8601 format
}
```

Export a `CalendarService` class:

**Constructor:** `constructor(client: DAVClientType, logger: Logger)`
- Store client and logger as private readonly fields
- Create a private `objectCache: CollectionCache<DAVCalendarObject>` initialized with the logger
- Create a private `calendars: DAVCalendar[]` initialized as empty array

**Method `listCalendars(): Promise<DAVCalendar[]>`:**
- If `this.calendars` is already populated (length > 0), return it (lazy initialization)
- Otherwise, call `withRetry(() => discoverCalendars(this.client, this.logger), this.logger)`
- Store result in `this.calendars`
- Return the array

**Method `refreshCalendars(): Promise<DAVCalendar[]>`:**
- Always re-discovers calendars (bypasses lazy cache)
- Calls `withRetry(() => discoverCalendars(this.client, this.logger), this.logger)`
- Stores in `this.calendars`
- Clears the objectCache (`this.objectCache.clear()`) since calendars may have changed
- Returns the array

**Method `fetchEvents(calendar: DAVCalendar, timeRange?: TimeRange): Promise<DAVCalendarObject[]>`:**
- First, check if cached objects are fresh using CTag:
  - If `calendar.ctag` exists AND `this.objectCache.isFresh(calendar.url, calendar.ctag)`:
    - Log debug: `{ url: calendar.url }`, "Using cached calendar objects (CTag match)"
    - Return `this.objectCache.get(calendar.url)!.objects`
  - NOTE: If timeRange is provided, skip the cache entirely (time-filtered queries should always go to server since cache stores unfiltered data). Log debug: "Skipping cache for time-range query"
- If not cached or stale:
  - If no timeRange provided AND cached entry exists, use `isCollectionDirty`:
    ```typescript
    const cached = this.objectCache.get(calendar.url);
    if (cached) {
      const { isDirty, newCtag } = await withRetry(
        () => this.client.isCollectionDirty({ collection: { ...calendar, ctag: cached.ctag } }),
        this.logger
      );
      if (!isDirty) {
        this.logger.debug({ url: calendar.url }, 'Calendar unchanged (CTag match via server check)');
        return cached.objects;
      }
      this.logger.info({ url: calendar.url, oldCtag: cached.ctag, newCtag }, 'Calendar changed, re-fetching');
    }
  - Call tsdav with retry:
    ```typescript
    const objects = await withRetry(
      () => this.client.fetchCalendarObjects({
        calendar,
        ...(timeRange ? { timeRange } : {}),
      }),
      this.logger
    );
    ```
  - If no timeRange (full fetch), update cache: `this.objectCache.set(calendar.url, calendar.ctag ?? '', objects)`
  - Log info: `{ url: calendar.url, count: objects.length, cached: !timeRange }`, "Fetched calendar objects"
  - Return objects

**Method `fetchAllEvents(timeRange?: TimeRange): Promise<DAVCalendarObject[]>`:**
- Call `this.listCalendars()` first to ensure calendars are loaded
- Use `Promise.all` to fetch events from ALL calendars in parallel:
  ```typescript
  const results = await Promise.all(
    this.calendars.map(cal => this.fetchEvents(cal, timeRange))
  );
  ```
- Flatten: `return results.flat()`
- Log info: `{ calendarCount: this.calendars.length, totalObjects: flattened.length }`, "Fetched events from all calendars"

IMPORTANT design decisions:
- This service returns RAW `DAVCalendarObject[]`, NOT `EventDTO[]`. Transformation happens in Phase 4.
- The cache stores full (unfiltered) objects. Time-range queries bypass the cache because the server filters differently.
- CTag comparison uses both local check (`isFresh`) and server round-trip (`isCollectionDirty`) depending on whether we have a prior CTag.
- All tsdav calls wrapped in `withRetry()` for resilience.

Use `.js` extension on all local imports. No console.log.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors. Verify that CalendarService, TimeRange are exported.
  </verify>
  <done>
`src/caldav/calendar-service.ts` exports CalendarService class with listCalendars, refreshCalendars, fetchEvents, and fetchAllEvents methods. CTag caching used for non-time-range queries. All tsdav calls wrapped in withRetry. File compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` succeeds with zero errors
2. `src/caldav/calendar-service.ts` exports CalendarService and TimeRange
3. CalendarService constructor accepts DAVClientType and Logger
4. listCalendars() uses lazy initialization with retry
5. fetchEvents() checks CTag cache before fetching, uses isCollectionDirty for server-side verification
6. fetchAllEvents() aggregates across all calendars using Promise.all
7. Time-range queries bypass cache (go directly to server)
8. All tsdav calls wrapped in withRetry
9. All imports use `.js` extensions
10. No `console.log` -- logger only
</verification>

<success_criteria>
- CalendarService can list all calendars via discoverCalendars (CAL-05)
- CalendarService can fetch events from all calendars (CAL-06 multi-calendar)
- CTag-based caching avoids unnecessary re-fetches (INF-04)
- Retry logic applied to all network calls (INF-04 connection error handling)
- Time-range filtering passed through to tsdav for server-side filtering
- Returns raw DAVCalendarObject arrays (transformation deferred to Phase 4)
</success_criteria>

<output>
After completion, create `.planning/phases/03-caldav-carddav-client-integration/03-03-SUMMARY.md`
</output>
