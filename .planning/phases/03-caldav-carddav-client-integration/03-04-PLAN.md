---
phase: 03-caldav-carddav-client-integration
plan: 04
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - src/caldav/addressbook-service.ts
autonomous: true

must_haves:
  truths:
    - "All address books for the authenticated user can be listed with display names"
    - "VCards (contacts) can be fetched from a single address book"
    - "VCards can be fetched from ALL address books (multi-addressbook aggregation)"
    - "CTag cache prevents re-fetching unchanged address books"
    - "Network failures trigger retry with exponential backoff"
    - "Fetched DAVVCard objects include url, etag, and raw data fields"
    - "Empty vCard results trigger a fallback fetch with useMultiGet disabled"
  artifacts:
    - path: "src/caldav/addressbook-service.ts"
      provides: "AddressBookService class with listAddressBooks, fetchContacts, fetchAllContacts methods"
      exports: ["AddressBookService"]
  key_links:
    - from: "src/caldav/addressbook-service.ts"
      to: "src/caldav/client.ts"
      via: "uses DAVClientType for tsdav operations"
      pattern: "import.*DAVClientType.*client\\.js"
    - from: "src/caldav/addressbook-service.ts"
      to: "src/caldav/cache.ts"
      via: "uses CollectionCache for CTag-based caching"
      pattern: "import.*CollectionCache.*cache\\.js"
    - from: "src/caldav/addressbook-service.ts"
      to: "src/caldav/retry.ts"
      via: "wraps tsdav calls in withRetry"
      pattern: "import.*withRetry.*retry\\.js"
    - from: "src/caldav/addressbook-service.ts"
      to: "src/caldav/discovery.ts"
      via: "uses discoverAddressBooks for initial listing"
      pattern: "import.*discoverAddressBooks.*discovery\\.js"
    - from: "src/caldav/addressbook-service.ts"
      to: "tsdav fetchVCards"
      via: "calls client.fetchVCards with addressBook parameter"
      pattern: "fetchVCards"
    - from: "src/caldav/addressbook-service.ts"
      to: "tsdav isCollectionDirty"
      via: "checks CTag before re-fetching cached contacts"
      pattern: "isCollectionDirty"
---

<objective>
Create the address book service that fetches address books and vCards with caching and retry.

Purpose: This service mirrors CalendarService for the CardDAV side. It wraps tsdav's addressbook operations with CTag-based caching (INF-04) and retry logic, implementing multi-addressbook aggregation. It returns raw DAVVCard arrays -- transformation into ContactDTOs will happen in Phase 5's query layer.

Output: An AddressBookService class that Phase 5 and Phase 5 (index.ts wiring) will use.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-caldav-carddav-client-integration/03-RESEARCH.md

@src/caldav/client.ts
@src/types/dtos.ts
@src/transformers/contact.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AddressBookService class</name>
  <files>src/caldav/addressbook-service.ts</files>
  <action>
Create `src/caldav/addressbook-service.ts`:

Imports:
- `type { Logger } from 'pino'`
- `type { DAVAddressBook } from 'tsdav'` (if not available, use `type { DAVCollection as DAVAddressBook } from 'tsdav'`)
- `type { DAVClientType } from './client.js'`
- `{ CollectionCache } from './cache.js'`
- `{ withRetry } from './retry.js'`
- `{ discoverAddressBooks } from './discovery.js'`

Define a local `DAVVCard` interface (tsdav may not export it directly -- check first, use tsdav's export if available):
```typescript
interface DAVVCard {
  url: string;
  etag?: string;
  data?: string;
}
```

Export an `AddressBookService` class:

**Constructor:** `constructor(client: DAVClientType, logger: Logger)`
- Store client and logger as private readonly fields
- Create a private `objectCache: CollectionCache<DAVVCard>` initialized with the logger
- Create a private `addressBooks: DAVAddressBook[]` initialized as empty array

**Method `listAddressBooks(): Promise<DAVAddressBook[]>`:**
- If `this.addressBooks` is already populated (length > 0), return it (lazy initialization)
- Otherwise, call `withRetry(() => discoverAddressBooks(this.client, this.logger), this.logger)`
- Store result in `this.addressBooks`
- Return the array

**Method `refreshAddressBooks(): Promise<DAVAddressBook[]>`:**
- Always re-discovers address books (bypasses lazy cache)
- Calls `withRetry(() => discoverAddressBooks(this.client, this.logger), this.logger)`
- Stores in `this.addressBooks`
- Clears the objectCache
- Returns the array

**Method `fetchContacts(addressBook: DAVAddressBook): Promise<DAVVCard[]>`:**
- Check if cached objects are fresh using CTag:
  - If `addressBook.ctag` exists AND `this.objectCache.isFresh(addressBook.url, addressBook.ctag)`:
    - Log debug: `{ url: addressBook.url }`, "Using cached address book contacts (CTag match)"
    - Return `this.objectCache.get(addressBook.url)!.objects`
- If cached entry exists, use `isCollectionDirty` to check server:
  ```typescript
  const cached = this.objectCache.get(addressBook.url);
  if (cached) {
    const { isDirty, newCtag } = await withRetry(
      () => this.client.isCollectionDirty({ collection: { ...addressBook, ctag: cached.ctag } }),
      this.logger
    );
    if (!isDirty) {
      this.logger.debug({ url: addressBook.url }, 'Address book unchanged (CTag match via server check)');
      return cached.objects;
    }
    this.logger.info({ url: addressBook.url, oldCtag: cached.ctag, newCtag }, 'Address book changed, re-fetching');
  }
  ```
- Fetch with retry:
  ```typescript
  let vcards = await withRetry(
    () => this.client.fetchVCards({ addressBook }),
    this.logger
  );
  ```
- IMPORTANT FALLBACK (Research Pitfall 5): If vcards is empty AND this is a non-empty address book (we can't know for certain, so always try fallback):
  ```typescript
  if (vcards.length === 0) {
    this.logger.info({ url: addressBook.url }, 'fetchVCards returned empty, retrying without multiGet');
    vcards = await withRetry(
      () => this.client.fetchVCards({ addressBook, useMultiGet: false }),
      this.logger
    );
  }
  ```
- Update cache: `this.objectCache.set(addressBook.url, addressBook.ctag ?? '', vcards)`
- Log info: `{ url: addressBook.url, count: vcards.length }`, "Fetched address book contacts"
- Return vcards

**Method `fetchAllContacts(): Promise<DAVVCard[]>`:**
- Call `this.listAddressBooks()` first to ensure address books are loaded
- Use `Promise.all` to fetch contacts from ALL address books in parallel:
  ```typescript
  const results = await Promise.all(
    this.addressBooks.map(ab => this.fetchContacts(ab))
  );
  ```
- Flatten: `return results.flat()`
- Log info: `{ addressBookCount: this.addressBooks.length, totalContacts: flattened.length }`, "Fetched contacts from all address books"

IMPORTANT design decisions:
- Returns RAW DAVVCard[] (with url, etag, data fields), NOT ContactDTO[]. Transformation happens in Phase 5.
- The multiGet fallback handles SabreDAV configurations that may not support addressbook-multiget REPORT.
- Address books don't have time-range queries, so ALL fetches are cacheable (unlike calendar service).
- All tsdav calls wrapped in `withRetry()`.

Use `.js` extension on all local imports. No console.log.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors. Verify that AddressBookService is exported.
  </verify>
  <done>
`src/caldav/addressbook-service.ts` exports AddressBookService class with listAddressBooks, refreshAddressBooks, fetchContacts, and fetchAllContacts methods. CTag caching used for all queries. MultiGet fallback implemented. All tsdav calls wrapped in withRetry. File compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` succeeds with zero errors
2. `src/caldav/addressbook-service.ts` exports AddressBookService
3. AddressBookService constructor accepts DAVClientType and Logger
4. listAddressBooks() uses lazy initialization with retry
5. fetchContacts() checks CTag cache, uses isCollectionDirty, has multiGet fallback
6. fetchAllContacts() aggregates across all address books using Promise.all
7. All tsdav calls wrapped in withRetry
8. Empty fetchVCards result triggers retry with `useMultiGet: false`
9. All imports use `.js` extensions
10. No `console.log` -- logger only
</verification>

<success_criteria>
- AddressBookService can list all address books via discoverAddressBooks
- AddressBookService can fetch contacts from all address books (multi-addressbook)
- CTag-based caching avoids unnecessary re-fetches (INF-04)
- Retry logic applied to all network calls (INF-04 connection error handling)
- MultiGet fallback handles servers that don't support addressbook-multiget
- Returns raw DAVVCard arrays (transformation deferred to Phase 5)
</success_criteria>

<output>
After completion, create `.planning/phases/03-caldav-carddav-client-integration/03-04-SUMMARY.md`
</output>
